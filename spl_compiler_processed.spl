type DataArray = array[99999] of int;
type HashMapKeyBuffer = array[64] of int;
type HashMapComponent = array[2048] of int;
type HashMap = array[5] of HashMapComponent;
type SymbolTables = array[128] of HashMap;
proc hash_string(ref data: HashMapKeyBuffer, length: int, ref result: int) {
    var h: int;
    var i: int;
    var c: int;
    h := 0;
    i := 0;
    while (i < length) {
        c := data[i];
        h := h * 31 + c;
        while (h >= 2048) {
            h := h - 2048;
        }
        i := i + 1;
    }
    result := h;
}
proc string_equals_buf_pool(
    ref buf: HashMapKeyBuffer,
    len1: int,
    ref pool: HashMapComponent,
    s2: int, len2: int,
    ref result: int
) {
    var i: int;
    var c1: int;
    var c2: int;
    result := 0;
    if (len1 = len2) {
        i := 0;
        result := 1;
        while (i < len1) {
            c1 := buf[i];
            c2 := pool[s2 + i + 1];
            if (c1 # c2) {
                result := 0;
                i := len1;
            } else {
                i := i + 1;
            }
        }
    }
}
proc hashmap_cpy_key(ref source: DataArray, ref target: HashMapKeyBuffer, start: int, length: int) {
    var i: int;
    i := 0;
    while (i < length) {
        target[i] := source[start + i];
        i := i + 1;
    }
}
proc hashmap_init(ref map: HashMap) {
    var i: int;
    map[4][0] := 1;
    i := 0;
    while (i < 2048) {
        map[3][i] := 0;
        i := i + 1;
    }
}
proc hashmap_put_str(
    ref map: HashMap,
    ref keyBuf: HashMapKeyBuffer,
    keyLen: int,
    value: int
) {
    var h: int;
    var idx: int;
    var i: int;
    var eq: int;
    var poolPos: int;
    var j: int;
    hash_string(keyBuf, keyLen, h);
    idx := h;
    i := 0;
    while (i < 2048) {
        if (map[3][idx] = 0) {
            poolPos := map[4][0];
            j := 0;
            while (j < keyLen) {
                map[4][poolPos + j] := keyBuf[j];
                j := j + 1;
            }
            map[4][0] := poolPos + keyLen;
            map[3][idx] := 1;
            map[0][idx] := poolPos - 1;
            map[1][idx] := keyLen;
            map[2][idx] := value;
            i := 2048;
        } else {
            string_equals_buf_pool(
                keyBuf, keyLen,
                map[4],
                map[0][idx], map[1][idx],
                eq
            );
            if (eq # 0) {
                map[2][idx] := value;
                i := 2048;
            } else {
                idx := idx + 1;
                if (idx = 2048) {
                    idx := 0;
                }
                i := i + 1;
            }
        }
    }
}
proc hashmap_get_str(
    ref map: HashMap,
    ref keyBuf: HashMapKeyBuffer,
    keyLen: int,
    ref found: int,
    ref result: int
) {
    var h: int;
    var idx: int;
    var i: int;
    var eq: int;
    hash_string(keyBuf, keyLen, h);
    idx := h;
    found := 0;
    i := 0;
    while (i < 2048) {
        if (map[3][idx] = 0) {
            i := 2048;
        } else {
            string_equals_buf_pool(
                keyBuf, keyLen,
                map[4],
                map[0][idx], map[1][idx],
                eq
            );
            if (eq # 0) {
                found := 1;
                result := map[2][idx];
                i := 2048;
            } else {
                idx := idx + 1;
                if (idx = 2048) {
                    idx := 0;
                }
                i := i + 1;
            }
        }
    }
}
proc array_cpy(ref source: DataArray, ref target: DataArray, start: int, length: int, startOffset: int) {
    var i: int;
    i := 0;
    while (i < length) {
        target[i + startOffset] := source[start + i];
        i := i + 1;
    }
}
proc print_array(ref source: DataArray, start: int, length: int) {
    var i: int;
    i := 0;
    while (i < length) {
        printc(source[start + i]);
        i := i + 1;
    }
}
proc read_input(ref input: DataArray, ref length: int) {
    var char: int;
    var index: int;
    readc(char);
    input[0] := char;
    index := 1;
    while (char # 0x2E) {
        readc(char);
        input[index] := char;
        index := index + 1;
    }
    input[index - 1] := 0;
    length := index - 1;
}
proc lex_is_whitespace(c: int, ref r: int) {
    var space: int;
    var lineFeed: int;
    var carriageReturn: int;
    var horizontalTab: int;
    r := 0;
    if (c = ' ') {
        r := 1;
    }
    if (c = 10) {
        r := 1;
    }
    if (c = 0xD) {
        r := 1;
    }
    if (c = 0x9) {
        r := 1;
    }
}
proc lex_is_digit(c: int, ref r: int) {
    r := 0;
    if (c >= 0x30) {
        if (c <= 0x39) {
            r := 1;
        }
    }
}
proc lex_is_alphanumeric_or_underscore(c: int, ref r: int) {
    r := 0;
    lex_is_digit(c, r);
    if (c >= 0x41) {
        if (c <= 0x5A) {
            r := 1;
        }
    }
    if (c >= 0x61) {
        if (c <= 0x7A) {
            r := 1;
        }
    }
    if (c = '_') {
        r := 1;
    }
}
proc lex_hex_to_int(c: int, ref r: int) {
    r := -1;
    if (c >= 'a') {
        if (c <= 'f') {
            r := c - 87;
        }
    }
    if (c >= 'A') {
        if (c <= 'F') {
            r := c - 55;
        }
    }
    if (c >= '0') {
        if (c <= '9') {
            r := ((c) - 0x30);
        }
    }
}
proc lex_eat_whitespace(ref input: DataArray, ref charPointer: int) {
    var isWhitespace: int;
    lex_is_whitespace(input[charPointer], isWhitespace);
    while (isWhitespace # 0) {
        charPointer := charPointer + 1;
        lex_is_whitespace(input[charPointer], isWhitespace);
    }
}
proc lex_eat_comment(ref input: DataArray, ref charPointer: int) {
    var continue: int;
    continue := 1;
    if (input[charPointer] = '/') {
        if (input[charPointer + 1] = '/') {
            while (continue # 0) {
                charPointer := charPointer + 1;
                continue := 0;
                if (input[charPointer] # 10) {
                    if (input[charPointer] # 0) {
                        continue := 1;
                    }
                }
            }
            lex_eat_whitespace(input, charPointer);
            lex_eat_comment(input, charPointer);
        }
    }
}
proc lex_read_ident(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var startIndex: int;
    var isCurrentCharAlphaOrUnderscore: int;
    var length: int;
    startIndex := charPointer;
    lex_is_alphanumeric_or_underscore(input[charPointer], isCurrentCharAlphaOrUnderscore);
    while (isCurrentCharAlphaOrUnderscore # 0) {
        charPointer := charPointer + 1;
        lex_is_alphanumeric_or_underscore(input[charPointer], isCurrentCharAlphaOrUnderscore);
    }
    length := charPointer - startIndex;
    tokens[tokenPointer] := length;
    tokenPointer := tokenPointer + 1;
    array_cpy(input, tokens, startIndex, length, tokenPointer);
    tokenPointer := tokenPointer + length;
    charPointer := charPointer - 1;
}
proc lex_read_char_lit(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var readChar: int;
    charPointer := charPointer + 1;
    if (input[charPointer] = 0x5C) {
        if (input[charPointer + 1] = 'n') {
            charPointer := charPointer + 1;
            readChar := '\n';
        } else {
            exit();
        }
    } else {
        readChar := input[charPointer];
    }
    charPointer := charPointer + 1;
    if (input[charPointer] # 0x27) {
        exit();
    }
    tokens[tokenPointer] := readChar;
    tokenPointer := tokenPointer + 1;
}
proc lex_read_decimal_int(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var parsed: int;
    var isDigit: int;
    parsed := ((input[charPointer]) - 0x30);
    charPointer := charPointer + 1;
    lex_is_digit(input[charPointer], isDigit);
    while (isDigit # 0) {
        parsed := parsed * 10 + ((input[charPointer]) - 0x30);
        charPointer := charPointer + 1;
        lex_is_digit(input[charPointer], isDigit);
    }
    charPointer := charPointer - 1;
    tokens[tokenPointer] := parsed;
    tokenPointer := tokenPointer + 1;
}
proc lex_read_hex_int(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var parsed: int;
    var decimal: int;
    parsed := 0;
    charPointer := charPointer + 1;
    charPointer := charPointer + 1;
    lex_hex_to_int(input[charPointer], decimal);
    if (decimal = -1) {
        exit();
    }
    while (decimal # -1) {
        parsed := parsed * 16 + decimal;
        charPointer := charPointer + 1;
        lex_hex_to_int(input[charPointer], decimal);
    }
    charPointer := charPointer - 1;
    tokens[tokenPointer] := parsed;
    tokenPointer := tokenPointer + 1;
}
proc lex_match_keyword(ref input: DataArray, ref charPointer: int, ref keyword: int) {
    var isEnd: int;
    keyword := -1;
    if (input[charPointer + (0)] = 'i') if (input[charPointer + (1)] = 'f') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 2], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 1;
            keyword := 2;
        }
    }
    if (input[charPointer + (0)] = 'e') if (input[charPointer + (1)] = 'l') if (input[charPointer + (2)] = 's') if (input[charPointer + (3)] = 'e') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 4], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 3;
            keyword := 3;
        }
    }
    if (input[charPointer + (0)] = 'w') if (input[charPointer + (1)] = 'h') if (input[charPointer + (2)] = 'i') if (input[charPointer + (3)] = 'l') if (input[charPointer + (4)] = 'e') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 5], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 4;
            keyword := 4;
        }
    }
    if (input[charPointer + (0)] = 'a') if (input[charPointer + (1)] = 'r') if (input[charPointer + (2)] = 'r') if (input[charPointer + (3)] = 'a') if (input[charPointer + (4)] = 'y') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 5], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 4;
            keyword := 5;
        }
    }
    if (input[charPointer + (0)] = 'o') if (input[charPointer + (1)] = 'f') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 2], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 1;
            keyword := 6;
        }
    }
    if (input[charPointer + (0)] = 'p') if (input[charPointer + (1)] = 'r') if (input[charPointer + (2)] = 'o') if (input[charPointer + (3)] = 'c') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 4], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 3;
            keyword := 7;
        }
    }
    if (input[charPointer + (0)] = 'r') if (input[charPointer + (1)] = 'e') if (input[charPointer + (2)] = 'f'){
        lex_is_alphanumeric_or_underscore(input[charPointer + 3], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 2;
            keyword := 8;
        }
    }
    if (input[charPointer + (0)] = 't') if (input[charPointer + (1)] = 'y') if (input[charPointer + (2)] = 'p') if (input[charPointer + (3)] = 'e') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 4], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 3;
            keyword := 9;
        }
    }
    if (input[charPointer + (0)] = 'v') if (input[charPointer + (1)] = 'a') if (input[charPointer + (2)] = 'r') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 3], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 2;
            keyword := 10;
        }
    }
}
proc lex(ref tokens: DataArray, ref tokenPointer: int, ref input: DataArray, inputLength: int) {
    var charPointer: int;
    var currentChar: int;
    var peekChar: int;
    var isDigit: int;
    var isAlphaOrUnderscore: int;
    var matchedKeyword: int;
    charPointer := 0;
    tokenPointer := 0;
    while (charPointer < inputLength) {
        lex_eat_whitespace(input, charPointer);
        lex_eat_comment(input, charPointer);
        currentChar := input[charPointer];
        peekChar := input[charPointer + 1];
        lex_is_digit(currentChar, isDigit);
        lex_is_alphanumeric_or_underscore(currentChar, isAlphaOrUnderscore);
        if (currentChar = ';') {
            tokens[tokenPointer] := 28; tokenPointer := tokenPointer + 1;
        } else if (currentChar = ',') {
            tokens[tokenPointer] := 29; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '(') {
            tokens[tokenPointer] := 11; tokenPointer := tokenPointer + 1;
        } else if (currentChar = ')') {
            tokens[tokenPointer] := 12; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '{') {
            tokens[tokenPointer] := 15; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '}') {
            tokens[tokenPointer] := 16; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '[') {
            tokens[tokenPointer] := 13; tokenPointer := tokenPointer + 1;
        } else if (currentChar = ']') {
            tokens[tokenPointer] := 14; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '+') {
            tokens[tokenPointer] := 23; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '-') {
            tokens[tokenPointer] := 24; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '*') {
            tokens[tokenPointer] := 25; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '/') {
            tokens[tokenPointer] := 26; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '=') {
            tokens[tokenPointer] := 17; tokenPointer := tokenPointer + 1;
        } else if (currentChar = '#') {
            tokens[tokenPointer] := 18; tokenPointer := tokenPointer + 1;
        } else if (currentChar = 0) {
            tokens[tokenPointer] := 31; tokenPointer := tokenPointer + 1;
        } else if (currentChar = ':') {
            if (peekChar = '=') {
                charPointer := charPointer + 1;
                tokens[tokenPointer] := 30; tokenPointer := tokenPointer + 1;
            } else {
                tokens[tokenPointer] := 27; tokenPointer := tokenPointer + 1;
            }
        } else if (currentChar = '<') {
            if (peekChar = '=') {
                charPointer := charPointer + 1;
                tokens[tokenPointer] := 20; tokenPointer := tokenPointer + 1;
            } else {
                tokens[tokenPointer] := 19; tokenPointer := tokenPointer + 1;
            }
        } else if (currentChar = '>') {
            if (peekChar = '=') {
                charPointer := charPointer + 1;
                tokens[tokenPointer] := 22; tokenPointer := tokenPointer + 1;
            } else {
                tokens[tokenPointer] := 21; tokenPointer := tokenPointer + 1;
            }
        } else if (currentChar = 0x27) {
            tokens[tokenPointer] := 1; tokenPointer := tokenPointer + 1;
            lex_read_char_lit(input, charPointer, tokens, tokenPointer);
        } else if (isDigit # 0) {
            tokens[tokenPointer] := 1; tokenPointer := tokenPointer + 1;
            if (currentChar = '0') {
                if (peekChar = 'x') {
                    lex_read_hex_int(input, charPointer, tokens, tokenPointer);
                } else {
                    lex_read_decimal_int(input, charPointer, tokens, tokenPointer);
                }
            } else {
                lex_read_decimal_int(input, charPointer, tokens, tokenPointer);
            }
        } else if (isAlphaOrUnderscore # 0) {
            lex_match_keyword(input, charPointer, matchedKeyword);
            if (matchedKeyword # -1) {
                tokens[tokenPointer] := matchedKeyword; tokenPointer := tokenPointer + 1;
            } else {
                tokens[tokenPointer] := 0; tokenPointer := tokenPointer + 1;
                lex_read_ident(input, charPointer, tokens, tokenPointer);
            }
        } else {
            tokens[tokenPointer] := 32; tokenPointer := tokenPointer + 1;
        }
        charPointer := charPointer + 1;
    }
    tokens[tokenPointer] := 31; tokenPointer := tokenPointer + 1;
}
proc lex_print_tokens(ref tokens: DataArray, tokenPointer: int) {
    var head: int;
    var i: int;
    var t: int;
    i := 0;
    while (i < tokenPointer) {
        head := tokens[i];
        if (head = 0) {
            printc('I'); printc('D'); printc('E'); printc('N'); printc('T'); printc(' ');
            i := i + 1;
            t := i + tokens[i];
            while (i < t) {
                printc(tokens[i + 1]);
                i := i + 1;
            }
        } else if (head = 1) {
            printc('I'); printc('N'); printc('T'); printc(' ');
            printi(tokens[i + 1]);
            i := i + 1;
        } else if (head = 2) {
            printc('I'); printc('F');
        } else if (head = 3) {
            printc('E'); printc('L'); printc('S'); printc('E');
        } else if (head = 4) {
            printc('W'); printc('H'); printc('I'); printc('L'); printc('E');
        } else if (head = 5) {
            printc('A'); printc('R'); printc('R'); printc('A'); printc('Y');
        } else if (head = 6) {
            printc('O'); printc('F');
        } else if (head = 7) {
            printc('P'); printc('R'); printc('O'); printc('C');
        } else if (head = 8) {
            printc('R'); printc('E'); printc('F');;
        } else if (head = 9) {
            printc('T'); printc('Y'); printc('P'); printc('E');
        } else if (head = 10) {
            printc('V'); printc('A'); printc('R');
        } else if (head = 11) {
            printc('L'); printc('P'); printc('A'); printc('R'); printc('E'); printc('N');
        } else if (head = 12) {
            printc('R'); printc('P'); printc('A'); printc('R'); printc('E'); printc('N');
        } else if (head = 13) {
            printc('L'); printc('B'); printc('R'); printc('A'); printc('C'); printc('K');
        } else if (head = 14) {
            printc('R'); printc('B'); printc('R'); printc('A'); printc('C'); printc('K');
        } else if (head = 15) {
            printc('L'); printc('C'); printc('U'); printc('R'); printc('L');
        } else if (head = 16) {
            printc('R'); printc('C'); printc('U'); printc('R'); printc('L');
        } else if (head = 17) {
            printc('E'); printc('Q'); printc('U'); printc('A'); printc('L');
        } else if (head = 18) {
            printc('H'); printc('A'); printc('S'); printc('H');
        } else if (head = 19) {
            printc('L'); printc('T');
        } else if (head = 20) {
            printc('L'); printc('T'); printc('E');
        } else if (head = 21) {
            printc('G'); printc('T');
        } else if (head = 22) {
            printc('G'); printc('T'); printc('E');
        } else if (head = 23) {
            printc('P'); printc('L'); printc('U'); printc('S');
        } else if (head = 24) {
            printc('M'); printc('I'); printc('N'); printc('U'); printc('S');
        } else if (head = 25) {
            printc('A'); printc('S'); printc('T'); printc('E'); printc('R'); printc('I'); printc('S'); printc('K');
        } else if (head = 26) {
            printc('S'); printc('L'); printc('A'); printc('S'); printc('H');
        } else if (head = 27) {
            printc('C'); printc('O'); printc('L'); printc('O'); printc('N');
        } else if (head = 28) {
            printc('S'); printc('E'); printc('M'); printc('I'); printc('C');
        } else if (head = 29) {
            printc('C'); printc('O'); printc('M'); printc('M'); printc('A');
        } else if (head = 30) {
            printc('A'); printc('S'); printc('S'); printc('G'); printc('N');
        } else if (head = 31) {
            printc('E'); printc('O'); printc('F');
        } else if (head = 32) {
            printc('I'); printc('l'); printc('l'); printc('e'); printc('g'); printc('a'); printc('l');
        }
        printc('\n');
        i := i + 1;
    }
}
proc parse_eat(type_: int, ref tokens: DataArray, ref tokenPointer: int) {
    var length: int;
    if (tokens[tokenPointer] = type_) {
        if (type_ = 0) {
            tokenPointer := tokenPointer + 1;
            length := tokens[tokenPointer];
            tokenPointer := tokenPointer + 1;
            tokenPointer := tokenPointer + length;
        } else if (type_ = 1) {
            tokenPointer := tokenPointer + 2;
        } else {
            tokenPointer := tokenPointer + 1;
        }
    } else {
        exit();
    }
}
proc parse_cpy_ident(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var length: int;
    var valueStart: int;
    length := tokens[tokenPointer + 1];
    valueStart := tokenPointer + 2;
    ast[astPointer] := length;
    astPointer := astPointer + 1;
    array_cpy(tokens, ast, valueStart, length, astPointer);
    astPointer := astPointer + length;
}
proc parse_type_expr(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    if (tokens[tokenPointer] = 5) {
        ast[astPointer] := (2); astPointer := astPointer + 1;
        nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
        ast[astPointer] := (0); astPointer := astPointer + 1;
        parse_eat((5), tokens, tokenPointer);
        parse_eat((13), tokens, tokenPointer);
        ast[astPointer] := (tokens[tokenPointer + 1]); astPointer := astPointer + 1;
        parse_eat((1), tokens, tokenPointer);
        parse_eat((14), tokens, tokenPointer);
        parse_eat((6), tokens, tokenPointer);;
        parse_type_expr(ast, astPointer, tokens, tokenPointer);
        ast[nodeLengthPos] := astPointer - nodeStart;
    } else if (tokens[tokenPointer] = 0) {
        ast[astPointer] := (10); astPointer := astPointer + 1;
        nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
        ast[astPointer] := (0); astPointer := astPointer + 1;
        parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
        parse_eat((0), tokens, tokenPointer);
        ast[nodeLengthPos] := astPointer - nodeStart;
    } else {
        exit();
    }
}
proc parse_type_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (16); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_eat((9), tokens, tokenPointer);
    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    parse_eat((0), tokens, tokenPointer);
    parse_eat((17), tokens, tokenPointer);
    parse_type_expr(ast, astPointer, tokens, tokenPointer);
    parse_eat(28, tokens, tokenPointer);
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_param_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (12); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    ast[astPointer] := (0); astPointer := astPointer + 1;
    if (tokens[tokenPointer] = 8) {
        ast[astPointer] := (1); astPointer := astPointer + 1;
        parse_eat((8), tokens, tokenPointer);
    } else {
        ast[astPointer] := (0); astPointer := astPointer + 1;
    }
    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    parse_eat((0), tokens, tokenPointer);
    parse_eat((27), tokens, tokenPointer);
    parse_type_expr(ast, astPointer, tokens, tokenPointer);
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_param_decl_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (13); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    if (tokens[tokenPointer] # 12) {
        parse_param_decl(ast, astPointer, tokens, tokenPointer);
        while (tokens[tokenPointer] = 29) {
            parse_eat((29), tokens, tokenPointer);
            parse_param_decl(ast, astPointer, tokens, tokenPointer);
        }
    }
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_var_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (18); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_eat((10), tokens, tokenPointer);
    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    parse_eat((0), tokens, tokenPointer);
    parse_eat((27), tokens, tokenPointer);
    parse_type_expr(ast, astPointer, tokens, tokenPointer);
    parse_eat(28, tokens, tokenPointer);
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_expr(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    parse_comparison(ast, astPointer, tokens, tokenPointer);
}
proc parse_comparison(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var hasOp: int;
    var nodeLengthPos: int;
    var nodeStart: int;
    var op: int;
    var i: int;
    leftStart := astPointer;
    parse_numeric(ast, astPointer, tokens, tokenPointer);
    leftEnd := astPointer;
    hasOp := 0;
    if (tokens[tokenPointer] = 19) {
        hasOp := 1;
    }
    if (tokens[tokenPointer] = 20) {
        hasOp := 1;
    }
    if (tokens[tokenPointer] = 21) {
        hasOp := 1;
    }
    if (tokens[tokenPointer] = 22) {
        hasOp := 1;
    }
    if (tokens[tokenPointer] = 17) {
        hasOp := 1;
    }
    if (tokens[tokenPointer] = 18) {
        hasOp := 1;
    }
    if (hasOp # 0) {
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 2] := ast[i];
            i := i - 1;
        }
        ast[leftStart] := 4;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        nodeStart := leftStart + 2;
        astPointer := leftEnd + 2;
        while (hasOp # 0) {
            op := tokens[tokenPointer];
            ast[astPointer] := (op); astPointer := astPointer + 1;;
            if (op = 19) {
                parse_eat((19), tokens, tokenPointer);
            } else if (op = 20) {
                parse_eat((20), tokens, tokenPointer);
            } else if (op = 21) {
                parse_eat((21), tokens, tokenPointer);
            } else if (op = 22) {
                parse_eat((22), tokens, tokenPointer);
            } else if (op = 17) {
                parse_eat((17), tokens, tokenPointer);
            } else {
                parse_eat((18), tokens, tokenPointer);
            }
            parse_numeric(ast, astPointer, tokens, tokenPointer);
            hasOp := 0;
            if (tokens[tokenPointer] = 19) {
                hasOp := 1;
            }
            if (tokens[tokenPointer] = 20) {
                hasOp := 1;
            }
            if (tokens[tokenPointer] = 21) {
                hasOp := 1;
            }
            if (tokens[tokenPointer] = 22) {
                hasOp := 1;
            }
            if (tokens[tokenPointer] = 17) {
                hasOp := 1;
            }
            if (tokens[tokenPointer] = 18) {
                hasOp := 1;
            }
        }
        ast[nodeLengthPos] := astPointer - nodeStart;
    }
}
proc parse_numeric(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var hasOp: int;
    var nodeLengthPos: int;
    var nodeStart: int;
    var op: int;
    var i: int;
    leftStart := astPointer;
    parse_term(ast, astPointer, tokens, tokenPointer);
    leftEnd := astPointer;
    hasOp := 0;
    if (tokens[tokenPointer] = 23) {
        hasOp := 1;
    }
    if (tokens[tokenPointer] = 24) {
        hasOp := 1;
    }
    if (hasOp # 0) {
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 2] := ast[i];
            i := i - 1;
        }
        ast[leftStart] := 4;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        nodeStart := leftStart + 2;
        astPointer := leftEnd + 2;
        while (hasOp # 0) {
            op := tokens[tokenPointer];
            ast[astPointer] := (op); astPointer := astPointer + 1;;
            if (op = 23) {
                parse_eat((23), tokens, tokenPointer);
            } else {
                parse_eat((24), tokens, tokenPointer);
            }
            parse_term(ast, astPointer, tokens, tokenPointer);
            hasOp := 0;
            if (tokens[tokenPointer] = 23) {
                hasOp := 1;
            }
            if (tokens[tokenPointer] = 24) {
                hasOp := 1;
            }
        }
        ast[nodeLengthPos] := astPointer - nodeStart;
    }
}
proc parse_term(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var hasOp: int;
    var nodeLengthPos: int;
    var nodeStart: int;
    var op: int;
    var i: int;
    leftStart := astPointer;
    parse_signed_factor(ast, astPointer, tokens, tokenPointer);
    leftEnd := astPointer;
    hasOp := 0;
    if (tokens[tokenPointer] = 25) {
        hasOp := 1;
    }
    if (tokens[tokenPointer] = 26) {
        hasOp := 1;
    }
    if (hasOp # 0) {
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 2] := ast[i];
            i := i - 1;
        }
        ast[leftStart] := 4;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        nodeStart := leftStart + 2;
        astPointer := leftEnd + 2;
        while (hasOp # 0) {
            op := tokens[tokenPointer];
            ast[astPointer] := (op); astPointer := astPointer + 1;;
            if (op = 25) {
                parse_eat((25), tokens, tokenPointer);
            } else {
                parse_eat((26), tokens, tokenPointer);
            }
            parse_signed_factor(ast, astPointer, tokens, tokenPointer);
            hasOp := 0;
            if (tokens[tokenPointer] = 25) {
                hasOp := 1;
            }
            if (tokens[tokenPointer] = 26) {
                hasOp := 1;
            }
        }
        ast[nodeLengthPos] := astPointer - nodeStart;
    }
}
proc parse_signed_factor(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    if (tokens[tokenPointer] = 24) {
        ast[astPointer] := (17); astPointer := astPointer + 1;
        nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
        ast[astPointer] := (24); astPointer := astPointer + 1;
        parse_eat((24), tokens, tokenPointer);
        parse_factor(ast, astPointer, tokens, tokenPointer);
        ast[nodeLengthPos] := astPointer - nodeStart;
    } else {
        parse_factor(ast, astPointer, tokens, tokenPointer);
    }
}
proc parse_factor(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    if (tokens[tokenPointer] = 0) {
        ast[astPointer] := (20); astPointer := astPointer + 1;
        nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
        parse_variable(ast, astPointer, tokens, tokenPointer);
        ast[nodeLengthPos] := astPointer - nodeStart;
    } else if (tokens[tokenPointer] = 1) {
        ast[astPointer] := (9); astPointer := astPointer + 1;
        nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
        ast[astPointer] := (tokens[tokenPointer + 1]); astPointer := astPointer + 1;
        parse_eat((1), tokens, tokenPointer);
        ast[nodeLengthPos] := astPointer - nodeStart;
    } else if (tokens[tokenPointer] = 11) {
        parse_eat((11), tokens, tokenPointer);
        parse_expr(ast, astPointer, tokens, tokenPointer);
        parse_eat((12), tokens, tokenPointer);
    } else {
        exit();
    }
}
proc parse_variable(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var nodeStart: int;
    var nodeLengthPos: int;
    var i: int;
    leftStart := astPointer;
    ast[astPointer] := (11); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    parse_eat((0), tokens, tokenPointer);
    ast[nodeLengthPos] := astPointer - nodeStart;
    leftEnd := astPointer;
    while (tokens[tokenPointer] = 13) {
        parse_eat((13), tokens, tokenPointer);
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 2] := ast[i];
            i := i - 1;
        }
        ast[leftStart] := 1;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        nodeStart := leftStart + 2;
        astPointer := leftEnd + 2;
        parse_expr(ast, astPointer, tokens, tokenPointer);
        parse_eat((14), tokens, tokenPointer);
        ast[nodeLengthPos] := astPointer - nodeStart;
        leftEnd := astPointer;
    }
}
proc parse_assgn_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (3); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_variable(ast, astPointer, tokens, tokenPointer);
    parse_eat((30), tokens, tokenPointer);
    parse_expr(ast, astPointer, tokens, tokenPointer);
    parse_eat(28, tokens, tokenPointer);
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_if_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (8); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_eat((2), tokens, tokenPointer);
    parse_eat((11), tokens, tokenPointer);
    parse_expr(ast, astPointer, tokens, tokenPointer);
    parse_eat((12), tokens, tokenPointer);
    parse_stmt(ast, astPointer, tokens, tokenPointer);
    if (tokens[tokenPointer] = 3) {
        parse_eat((3), tokens, tokenPointer);
        parse_stmt(ast, astPointer, tokens, tokenPointer);
    } else {
        ast[astPointer] := (7); astPointer := astPointer + 1;
        nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    }
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_compound_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (6); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_eat((15), tokens, tokenPointer);;
    parse_stmt_list(ast, astPointer, tokens, tokenPointer);
    parse_eat((16), tokens, tokenPointer);;
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_while_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (21); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_eat((4), tokens, tokenPointer);
    parse_eat((11), tokens, tokenPointer);
    parse_expr(ast, astPointer, tokens, tokenPointer);
    parse_eat((12), tokens, tokenPointer);
    parse_stmt(ast, astPointer, tokens, tokenPointer);
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_empty_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (7); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_eat(28, tokens, tokenPointer);
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_arg_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (0); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    if (tokens[tokenPointer] # 12) {
        parse_expr(ast, astPointer, tokens, tokenPointer);
        while (tokens[tokenPointer] = 29) {
            parse_eat((29), tokens, tokenPointer);
            parse_expr(ast, astPointer, tokens, tokenPointer);
        }
    }
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_call_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (5); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    parse_eat((0), tokens, tokenPointer);
    parse_eat((11), tokens, tokenPointer);
    parse_arg_list(ast, astPointer, tokens, tokenPointer);
    parse_eat((12), tokens, tokenPointer);
    parse_eat(28, tokens, tokenPointer);
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    if (tokens[tokenPointer] = 0) {
        if (tokens[tokenPointer + tokens[tokenPointer + 1] + 2] = 11) {
            parse_call_stmt(ast, astPointer, tokens, tokenPointer);
        } else {
            parse_assgn_stmt(ast, astPointer, tokens, tokenPointer);
        }
    } else if (tokens[tokenPointer] = 2) {
        parse_if_stmt(ast, astPointer, tokens, tokenPointer);
    } else if (tokens[tokenPointer] = 15) {
        parse_compound_stmt(ast, astPointer, tokens, tokenPointer);
    } else if (tokens[tokenPointer] = 4) {
        parse_while_stmt(ast, astPointer, tokens, tokenPointer);
    } else if (tokens[tokenPointer] = 28) {
        parse_empty_stmt(ast, astPointer, tokens, tokenPointer);
    }
}
proc parse_stmt_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    var continue: int;
    ast[astPointer] := (15); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    continue := 0;
    if (tokens[tokenPointer] # 16) {
        if (tokens[tokenPointer] # 31) {
            continue := 1;
        }
    }
    while (continue # 0) {
        parse_stmt(ast, astPointer, tokens, tokenPointer);
        continue := 0;
        if (tokens[tokenPointer] # 16) {
            if (tokens[tokenPointer] # 31) {
                continue := 1;
            }
        }
    }
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_var_decl_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (19); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    while (tokens[tokenPointer] = 10) {
        parse_var_decl(ast, astPointer, tokens, tokenPointer);
    }
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_proc_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    ast[astPointer] := (14); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    parse_eat((7), tokens, tokenPointer);
    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    parse_eat((0), tokens, tokenPointer);
    parse_eat((11), tokens, tokenPointer);
    parse_param_decl_list(ast, astPointer, tokens, tokenPointer);
    parse_eat((12), tokens, tokenPointer);
    parse_eat((15), tokens, tokenPointer);
    parse_var_decl_list(ast, astPointer, tokens, tokenPointer);
    parse_stmt_list(ast, astPointer, tokens, tokenPointer);
    parse_eat((16), tokens, tokenPointer);
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc parse_global(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    if (tokens[tokenPointer] = 9) {
        parse_type_decl(ast, astPointer, tokens, tokenPointer);
    } else if (tokens[tokenPointer] = 7) {
        parse_proc_decl(ast, astPointer, tokens, tokenPointer);
    } else {
        exit();
    }
}
proc parse_print_node_type(nodeType: int) {
    if (nodeType = 0) {
        printc('A'); printc('R'); printc('G'); printc('_'); printc('L'); printc('I'); printc('S'); printc('T');
    } else if (nodeType = 1) {
        printc('A'); printc('R'); printc('R'); printc('_'); printc('A'); printc('C'); printc('C');;
    } else if (nodeType = 2) {
        printc('A'); printc('R'); printc('R'); printc('_'); printc('T'); printc('Y'); printc('P'); printc('E'); printc('_'); printc('E'); printc('X'); printc('P'); printc('R');
    } else if (nodeType = 3) {
        printc('A'); printc('S'); printc('S');; printc('G'); printc('N'); printc('_'); printc('S'); printc('T'); printc('M'); printc('T');
    } else if (nodeType = 4) {
        printc('B'); printc('I'); printc('N'); printc('_'); printc('E'); printc('X'); printc('P'); printc('R');
    } else if (nodeType = 5) {
        printc('C'); printc('A'); printc('L'); printc('L'); printc('_'); printc('S'); printc('T'); printc('M'); printc('T');
    } else if (nodeType = 6) {
        printc('C'); printc('O'); printc('M'); printc('P'); printc('_'); printc('S'); printc('T'); printc('M'); printc('T');
    } else if (nodeType = 7) {
        printc('E'); printc('M'); printc('P'); printc('T'); printc('Y'); printc('_'); printc('S'); printc('T'); printc('M'); printc('T');
    } else if (nodeType = 8) {
        printc('I'); printc('F'); printc('_'); printc('S'); printc('T'); printc('M'); printc('T');
    } else if (nodeType = 9) {
        printc('I'); printc('N'); printc('T'); printc('_'); printc('L'); printc('I'); printc('T');
    } else if (nodeType = 10) {
        printc('N'); printc('A'); printc('M');; printc('E'); printc('D'); printc('_'); printc('T'); printc('Y'); printc('P'); printc('E'); printc('_'); printc('E'); printc('X'); printc('P'); printc('R');
    } else if (nodeType = 11) {
        printc('N'); printc('A'); printc('M');; printc('E'); printc('D'); printc('_'); printc('V'); printc('A'); printc('R');
    } else if (nodeType = 12) {
        printc('P'); printc('A'); printc('R'); printc('A'); printc('M'); printc('_'); printc('D'); printc('E'); printc('C'); printc('L');
    } else if (nodeType = 13) {
        printc('P'); printc('A'); printc('R'); printc('A'); printc('M'); printc('_'); printc('D'); printc('E'); printc('C'); printc('L'); printc('_'); printc('L'); printc('I'); printc('S'); printc('T');
    } else if (nodeType = 14) {
        printc('P'); printc('R'); printc('O'); printc('C'); printc('_'); printc('D'); printc('E'); printc('C'); printc('L');
    } else if (nodeType = 15) {
        printc('S'); printc('T'); printc('M'); printc('T'); printc('_'); printc('L'); printc('I'); printc('S'); printc('T');
    } else if (nodeType = 16) {
        printc('T'); printc('Y'); printc('P'); printc('E'); printc('_'); printc('D'); printc('E'); printc('C'); printc('L');
    } else if (nodeType = 17) {
        printc('U'); printc('N'); printc('A'); printc('_'); printc('E'); printc('X'); printc('P'); printc('R');
    } else if (nodeType = 18) {
        printc('V'); printc('A'); printc('R'); printc('_'); printc('D'); printc('E'); printc('C'); printc('L');
    } else if (nodeType = 19) {
        printc('V'); printc('A'); printc('R'); printc('_'); printc('D'); printc('E'); printc('C'); printc('L'); printc('_'); printc('L'); printc('I'); printc('S'); printc('T');
    } else if (nodeType = 20) {
        printc('V'); printc('A'); printc('R'); printc('_'); printc('E'); printc('X'); printc('P'); printc('R');
    } else if (nodeType = 21) {
        printc('W'); printc('H'); printc('I'); printc('L'); printc('E'); printc('_'); printc('S'); printc('T'); printc('M'); printc('T');
    }
}
proc parse_print_list(ref ast: DataArray, ref astPointer: int, nodeType: int) {
    while (ast[astPointer] = nodeType) {
        parse_print_ast_rec(ast, astPointer);
        if (ast[astPointer] = nodeType) {
            printc(','); printc(' ');
        }
    }
}
proc parse_print_ast_rec(ref ast: DataArray, ref astPointer: int) {
    var nodeType: int;
    var nodeLength: int;
    var t: int;
    nodeType := ast[astPointer];
    astPointer := astPointer + 1;
    nodeLength := ast[astPointer];
    astPointer := astPointer + 1;
    printc('(');
    parse_print_node_type(nodeType);
    printc(' ');
    if (nodeType = 16) {
        t := ast[astPointer]; astPointer := astPointer + 1; print_array(ast, astPointer, t); astPointer := astPointer + t;
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 10) {
        astPointer := astPointer + 1;
        t := ast[astPointer]; astPointer := astPointer + 1; print_array(ast, astPointer, t); astPointer := astPointer + t;
    } else if (nodeType = 2) {
        astPointer := astPointer + 1;
        printi(ast[astPointer]);
        astPointer := astPointer + 1;
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 14) {
        t := ast[astPointer]; astPointer := astPointer + 1; print_array(ast, astPointer, t); astPointer := astPointer + t;
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 13) {
        parse_print_list(ast, astPointer, 12);
    } else if (nodeType = 12) {
        astPointer := astPointer + 1;
        printi(ast[astPointer]);
        astPointer := astPointer + 1;
        printc(' ');
        t := ast[astPointer]; astPointer := astPointer + 1; print_array(ast, astPointer, t); astPointer := astPointer + t;
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 19) {
        parse_print_list(ast, astPointer, 18);
    } else if (nodeType = 18) {
        t := ast[astPointer]; astPointer := astPointer + 1; print_array(ast, astPointer, t); astPointer := astPointer + t;
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 15) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            parse_print_ast_rec(ast, astPointer);
            if (astPointer < t + nodeLength) {
                printc(',');
                printc(' ');
            }
        }
    } else if (nodeType = 3) {
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 11) {
        t := ast[astPointer]; astPointer := astPointer + 1; print_array(ast, astPointer, t); astPointer := astPointer + t;
    } else if (nodeType = 9) {
        printi(ast[astPointer]);
        astPointer := astPointer + 1;
    } else if (nodeType = 4) {
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        t := ast[astPointer];
        if (t = 17) {
            printc('=');
        } else if (t = 18) {
            printc('#');
        } else if (t = 19) {
            printc('<');
        } else if (t = 20) {
            printc('<'); printc('=');
        } else if (t = 21) {
            printc('>');
        } else if (t = 22) {
            printc('>'); printc('=');
        } else if (t = 23) {
            printc('+');
        } else if (t = 24) {
            printc('-');
        } else if (t = 25) {
            printc('*');
        } else if (t = 26) {
            printc('/');
        }
        astPointer := astPointer + 1;
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 1) {
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 8) {
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
    } else if (nodeType = 6) {
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 21) {
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 5) {
        t := ast[astPointer]; astPointer := astPointer + 1; print_array(ast, astPointer, t); astPointer := astPointer + t;
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 0) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            parse_print_ast_rec(ast, astPointer);
            if (astPointer < t + nodeLength) {
                printc(',');
                printc(' ');
            }
        }
    } else if (nodeType = 17) {
        t := ast[astPointer];
        astPointer := astPointer + 1;
        if (t = 24) {
            printc('-');
        }
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = 20) {
        parse_print_ast_rec(ast, astPointer);
    }
    printc(')');
}
proc parse_print_ast(ref ast: DataArray) {
    var astPointer: int;
    astPointer := 0;
    parse_print_ast_rec(ast, astPointer);
    printc('\n');
}
proc parse(ref ast: DataArray, ref tokens: DataArray) {
    var nodeStart: int;
    var nodeLengthPos: int;
    var astPointer: int;
    var tokenPointer: int;
    astPointer := 0;
    tokenPointer := 0;
    ast[astPointer] := (15); astPointer := astPointer + 1;
    nodeLengthPos := astPointer; ast[astPointer] := (0); astPointer := astPointer + 1; nodeStart := astPointer;
    while (tokens[tokenPointer] # 31) {
        parse_global(ast, astPointer, tokens, tokenPointer);
    }
    ast[nodeLengthPos] := astPointer - nodeStart;
}
proc symbol_table_lookup(
    ref symbolTables: SymbolTables,
    ref tablePointer: int,
    ref keyBuf: HashMapKeyBuffer,
    keyLen: int,
    ref found: int,
    ref result: int
) {
    hashmap_get_str(symbolTables[tablePointer], keyBuf, keyLen, found, result);
    if (found # 1) {
          hashmap_get_str(symbolTables[0], keyBuf, keyLen, found, result);
    }
}
proc symbol_table_enter(ref table: HashMap, ref keyBuf: HashMapKeyBuffer, keyLen: int, value: int) {
    var found: int;
    var result: int;
    hashmap_get_str(table, keyBuf, keyLen, found, result);
    if (found # 0) {
        exit();
    }
    hashmap_put_str(table, keyBuf, keyLen, value);
}
proc name_analysis_type_decl(
    ref ast: DataArray,
    ref astPointer: int,
    ref symbolTables: SymbolTables,
    ref tablePointer: int,
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var identLength: int;
    var identStart: int;
    var typeIndex: int;
    var entryStart: int;
    var mapFound: int;
    var mapValue: int;
    identLength := ast[astPointer];
    astPointer := astPointer + 1;
    identStart := astPointer;
    astPointer := astPointer + identLength;
    typeIndex := astPointer
        + 1
        + 1;
    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    entryStart := entryPointer;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 3; entryPointer := entryPointer + 1;
    entries[entryPointer] := ast[typeIndex]; entryPointer := entryPointer + 1;;
    hashmap_cpy_key(ast, keyBuf, identStart, identLength);
    symbol_table_enter(symbolTables[0], keyBuf, identLength, entryStart);
}
proc name_analysis_named_type_expr(
    ref ast: DataArray,
    ref astPointer: int,
    ref symbolTables: SymbolTables,
    ref tablePointer: int,
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var typeSlot: int;
    var identLength: int;
    var mapFound: int;
    var mapValue: int;
    typeSlot := astPointer;
    astPointer := astPointer + 1;
    identLength := ast[astPointer];
    astPointer := astPointer + 1;
    hashmap_cpy_key(ast, keyBuf, astPointer, identLength);
    astPointer := astPointer + identLength;
    symbol_table_lookup(symbolTables, tablePointer, keyBuf, identLength, mapFound, mapValue);
    if (mapFound # 1) {
        exit();
    }
    if (entries[mapValue] # 1) {
        exit();
    }
    ast[typeSlot] := mapValue + 1;
}
proc name_analysis_arr_type_expr(
    ref ast: DataArray,
    ref astPointer: int,
    ref symbolTables: SymbolTables,
    ref tablePointer: int,
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var typeSlot: int;
    var arrSize: int;
    var subTypeIndex: int;
    typeSlot := astPointer;
    astPointer := astPointer + 1;
    arrSize := ast[astPointer];
    astPointer := astPointer + 1;
    subTypeIndex := astPointer
        + 1
        + 1;
    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    ast[typeSlot] := entryPointer;
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := arrSize; entryPointer := entryPointer + 1;
    entries[entryPointer] := 3; entryPointer := entryPointer + 1;
    entries[entryPointer] := ast[subTypeIndex]; entryPointer := entryPointer + 1;
}
proc name_analysis_var_decl(
    ref ast: DataArray,
    ref astPointer: int,
    ref symbolTables: SymbolTables,
    ref tablePointer: int,
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var nameStart: int;
    var nameLen: int;
    var typeIndex: int;
    var entryStart: int;
    nameLen := ast[astPointer];
    astPointer := astPointer + 1;
    nameStart := astPointer;
    astPointer := astPointer + nameLen;
    typeIndex := astPointer
        + 1
        + 1;
    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    entryStart := entryPointer;
    entries[entryPointer] := 2; entryPointer := entryPointer + 1;
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := 3; entryPointer := entryPointer + 1;
    entries[entryPointer] := ast[typeIndex]; entryPointer := entryPointer + 1;;
    hashmap_cpy_key(ast, keyBuf, nameStart, nameLen);
    symbol_table_enter(symbolTables[tablePointer], keyBuf, nameLen, entryStart);
}
proc name_analysis_param_decl(
    ref ast: DataArray,
    ref astPointer: int,
    ref symbolTables: SymbolTables,
    ref tablePointer: int,
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var nameStart: int;
    var nameLen: int;
    var typeIndex: int;
    var entryStart: int;
    var isReference: int;
    var dataType: int;
    dataType := astPointer;
    astPointer := astPointer + 1;
    isReference := ast[astPointer];
    astPointer := astPointer + 1;
    nameLen := ast[astPointer];
    astPointer := astPointer + 1;
    nameStart := astPointer;
    astPointer := astPointer + nameLen;
    typeIndex := astPointer
        + 1
        + 1;
    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    if (entries[ast[typeIndex]] = 0) {
        if (isReference # 1) {
            exit();
        }
    }
    ast[dataType] := ast[typeIndex];
    entryStart := entryPointer;
    entries[entryPointer] := 2; entryPointer := entryPointer + 1;
    entries[entryPointer] := isReference; entryPointer := entryPointer + 1;
    entries[entryPointer] := 3; entryPointer := entryPointer + 1;
    entries[entryPointer] := ast[typeIndex]; entryPointer := entryPointer + 1;;
    hashmap_cpy_key(ast, keyBuf, nameStart, nameLen);
    symbol_table_enter(symbolTables[tablePointer], keyBuf, nameLen, entryStart);
}
proc name_analysis_proc_decl(
    ref ast: DataArray,
    ref astPointer: int,
    ref symbolTables: SymbolTables,
    ref tablePointer: int,
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var procNameStart: int;
    var procNameLen: int;
    var paramTypes: DataArray;
    var paramTypesPointer: int;
    var typeIndex: int;
    var isReference: int;
    var paramCounter: int;
    var entryStart: int;
    tablePointer := tablePointer + 1;
    paramCounter := 0;
    paramTypesPointer := 1;
    procNameLen := ast[astPointer];
    astPointer := astPointer + 1;
    procNameStart := astPointer;
    astPointer := astPointer + procNameLen;
    astPointer := astPointer + 1 + 1;
    while (ast[astPointer] = 12) {
        astPointer := astPointer + 2;
        typeIndex := astPointer;
        isReference := ast[astPointer + 1];
        name_analysis_param_decl(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
        paramTypes[paramTypesPointer] := isReference;
        paramTypes[paramTypesPointer + 1] := 3;
        paramTypes[paramTypesPointer + 2] := ast[typeIndex];
        paramTypesPointer := paramTypesPointer + 3;
        paramCounter := paramCounter + 1;
    }
    paramTypes[0] := paramCounter;
    astPointer := astPointer + 1 + 1;
    while (ast[astPointer] = 18) {
        astPointer := astPointer + 2;
        name_analysis_var_decl(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    }
    entryStart := entryPointer;
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := tablePointer; entryPointer := entryPointer + 1;
    array_cpy(paramTypes, entries, 0, paramTypesPointer, entryPointer);
    entryPointer := entryPointer + paramTypesPointer;
    hashmap_cpy_key(ast, keyBuf, procNameStart, procNameLen);
    symbol_table_enter(symbolTables[0], keyBuf, procNameLen, entryStart);
    astPointer := astPointer + 1 + 1 + ast[astPointer + 1];
}
proc name_analysis_check_main(ref table: HashMap, ref entries: DataArray) {
    var keyBuf: HashMapKeyBuffer;
    var found: int;
    var value: int;
    var parametersCount: int;
    keyBuf[0] := 'm';
    keyBuf[1] := 'a';
    keyBuf[2] := 'i';
    keyBuf[3] := 'n';
    hashmap_get_str(table, keyBuf, 4, found, value);
    if (found # 1) {
        exit();
    }
    if (entries[value] # 0) {
        exit();
    }
    if (entries[value + 2] # 0) {
        exit();
    }
}
proc name_analysis_rec(
    ref ast: DataArray,
    ref astPointer: int,
    ref symbolTables: SymbolTables,
    ref tablePointer: int,
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var nodeType: int;
    var nodeLength: int;
    var t: int;
    nodeType := ast[astPointer];
    astPointer := astPointer + 1;
    nodeLength := ast[astPointer];
    astPointer := astPointer + 1;
    if (nodeType = 16) {
        name_analysis_type_decl(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = 10) {
        name_analysis_named_type_expr(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = 2) {
        name_analysis_arr_type_expr(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = 14) {
        name_analysis_proc_decl(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = 15) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
        }
    } else {
        exit();
    }
}
proc name_analysis(ref ast: DataArray, ref symbolTables: SymbolTables, ref symbolTableEntries: DataArray, ref entryPointer: int) {
    var astPointer: int;
    var keyBuf: HashMapKeyBuffer;
    var tablePointer: int;
    astPointer := 0;
    tablePointer := 0;
    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, symbolTableEntries, entryPointer, keyBuf);
    name_analysis_check_main(symbolTables[0], symbolTableEntries);
}
proc init_global_table(ref table: HashMap, headless: int, ref entries: DataArray, ref entryPointer: int) {
    var keyBuf: HashMapKeyBuffer;
    keyBuf[0] := 'i';
    keyBuf[1] := 'n';
    keyBuf[2] := 't';
    hashmap_put_str(table, keyBuf, 3, entryPointer);
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    keyBuf[0] := 'p';
    keyBuf[1] := 'r';
    keyBuf[2] := 'i';
    keyBuf[3] := 'n';
    keyBuf[4] := 't';
    keyBuf[5] := 'i';
    hashmap_put_str(table, keyBuf, 6, entryPointer);
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := -1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    keyBuf[0] := 'p';
    keyBuf[1] := 'r';
    keyBuf[2] := 'i';
    keyBuf[3] := 'n';
    keyBuf[4] := 't';
    keyBuf[5] := 'c';
    hashmap_put_str(table, keyBuf, 6, entryPointer);
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := -1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    keyBuf[0] := 'r';
    keyBuf[1] := 'e';
    keyBuf[2] := 'a';
    keyBuf[3] := 'd';
    keyBuf[4] := 'i';
    hashmap_put_str(table, keyBuf, 5, entryPointer);
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := -1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    keyBuf[0] := 'r';
    keyBuf[1] := 'e';
    keyBuf[2] := 'a';
    keyBuf[3] := 'd';
    keyBuf[4] := 'c';
    hashmap_put_str(table, keyBuf, 5, entryPointer);
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := -1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    keyBuf[0] := 'e';
    keyBuf[1] := 'x';
    keyBuf[2] := 'i';
    keyBuf[3] := 't';
    hashmap_put_str(table, keyBuf, 4, entryPointer);
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := -1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    keyBuf[0] := 't';
    keyBuf[1] := 'i';
    keyBuf[2] := 'm';
    keyBuf[3] := 'e';
    hashmap_put_str(table, keyBuf, 4, entryPointer);
    entries[entryPointer] := 0; entryPointer := entryPointer + 1;
    entries[entryPointer] := -1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
    entries[entryPointer] := 1; entryPointer := entryPointer + 1;
}
proc print_type(ref entries: DataArray, ref entryPointer: int) {
    var head: int;
    var t: int;
    head := entries[entryPointer];
    entryPointer := entryPointer + 1;
    if (head = 1) {
        printc('i'); printc('n'); printc('t');
    } else if (head = 2) {
        printc('b'); printc('o'); printc('o'); printc('l');
    } else if (head = 0) {
        printc('a'); printc('r'); printc('r'); printc('a'); printc('y');
        printc('[');
        printi(entries[entryPointer]);
        entryPointer := entryPointer + 1;
        printc(']');
        printc(' '); printc('o'); printc('f'); printc(' ');
        print_type(entries, entryPointer);
    } else if (head = 3) {
        t := entryPointer;
        entryPointer := entries[entryPointer];
        print_type(entries, entryPointer);
        entryPointer := t + 1;
    } else {
        exit();
    }
}
proc print_procedure_type(ref entries: DataArray, ref entryPointer: int) {
    var i: int;
    var parameterCount: int;
    var isReference: int;
    parameterCount := entries[entryPointer];
    entryPointer := entryPointer + 1;
    i := 0;
    while (i < parameterCount) {
        isReference := entries[entryPointer];
        entryPointer := entryPointer + 1;
        if (isReference # 0) {
            printc('r'); printc('e'); printc('f'); printc(' ');
        }
        print_type(entries, entryPointer);
        i := i + 1;
        if (i < parameterCount) {
            printc(',');
            printc(' ');
        }
    }
}
proc print_table(ref symbolTable: HashMap, ref entries: DataArray) {
    var i: int;
    var start: int;
    var len: int;
    var j: int;
    var c: int;
    var valueFound: int;
    var entryPointer: int;
    var keyBuf: HashMapKeyBuffer;
    var isReference: int;
    i := 0;
    while (i < 2048) {
        if (symbolTable[3][i] # 0) {
            start := symbolTable[0][i];
            len := symbolTable[1][i];
            j := 0;
            while (j < len) {
                c := symbolTable[4][start + j + 1];
                printc(c);
                keyBuf[j] := c;
                j := j + 1;
            }
            printc(' '); printc('-'); printc('-'); printc('>'); printc(' ');
            hashmap_get_str(symbolTable, keyBuf, j, valueFound, entryPointer);
            if (entries[entryPointer] = 1) {
                entryPointer := entryPointer + 1;
                printc('t'); printc('y'); printc('p'); printc('e'); printc(':'); printc(' ');
                print_type(entries, entryPointer);
            } else if (entries[entryPointer] = 0) {
                entryPointer := entryPointer + 1;
                entryPointer := entryPointer + 1;
                printc('p'); printc('r'); printc('o'); printc('c'); printc(':'); printc(' '); printc('(');
                print_procedure_type(entries, entryPointer);
                printc(')');
            } else if (entries[entryPointer] = 2) {
                entryPointer := entryPointer + 1;
                isReference := entries[entryPointer];
                entryPointer := entryPointer + 1;
                printc('v'); printc('a'); printc('r'); printc(':'); printc(' ');
                if (isReference # 0) {
                    printc('r'); printc('e'); printc('f'); printc(' ');
                }
                print_type(entries, entryPointer);
            } else {
                exit();
            }
            printc('\n');
        }
        i := i + 1;
    }
}
proc print_tables(ref symbolTables: SymbolTables, ref entries: DataArray, count: int) {
    var i: int;
    i := 0;
    while (i < count) {
        printc('t'); printc('a'); printc('b'); printc('l'); printc('e'); printc(' '); printi(i);
        printc('\n');
        print_table(symbolTables[i], entries);
        printc('\n');
        i := i + 1;
    }
}
proc init_table_maps(ref symbolTables: SymbolTables) {
    var i: int;
    i := 0;
    while (i < 128) {
        hashmap_init(symbolTables[i]);
        i := i + 1;
    }
}
proc main() {
    var input: DataArray;
    var inputLength: int;
    var tokenPointer: int;
    var tokens: DataArray;
    var ast: DataArray;
    var symbolTables: SymbolTables;
    var symbolTableEntries: DataArray;
    var symbolTableEntryPointer: int;
    read_input(input, inputLength);
    lex(tokens, tokenPointer, input, inputLength);
    parse(ast, tokens);
    init_table_maps(symbolTables);
    symbolTableEntryPointer := 0;
    init_global_table(symbolTables[0], 0, symbolTableEntries, symbolTableEntryPointer);
    name_analysis(ast, symbolTables, symbolTableEntries, symbolTableEntryPointer);
    print_tables(symbolTables, symbolTableEntries, 128);
}
