#define LINE_FEED 10

#define PC(x) printc(x);

#define TOK_IDENT    0
#define TOK_INT      1
#define TOK_CHAR     2
#define TOK_IF       3
#define TOK_ELSE     4
#define TOK_WHILE    5
#define TOK_ARRAY    6
#define TOK_OF       7
#define TOK_PROC     8
#define TOK_REF      9
#define TOK_TYPE     10
#define TOK_VAR      11
#define TOK_LPAREN   12
#define TOK_RPAREN   13
#define TOK_LBRACK   14
#define TOK_RBRACK   15
#define TOK_LCURL    16
#define TOK_RCURL    17
#define TOK_EQUAL    18
#define TOK_HASH     19
#define TOK_LT       20
#define TOK_LTE      21
#define TOK_GT       22
#define TOK_GTE      23
#define TOK_PLUS     24
#define TOK_MINUS    25
#define TOK_ASTERISK 26
#define TOK_SLASH    27
#define TOK_COLON    28
#define TOK_SEMIC    29
#define TOK_COMMA    30
#define TOK_ASSGN    31
#define TOK_EOF      32
#define TOK_ILLEGAL  33

#define NEXT_CHAR charPointer := charPointer + 1;
#define TOKEN(type) tokens[tokenPointer] := type; tokenPointer := tokenPointer + 1;
#define K_MATCH(i, c) if (input[charPointer + (i)] = c)

#define CURR_TOK tokens[tokenPointer]

#define CHAR_TO_INT(c) ((c) - 0x30)

#define NODE_ARG_LIST        0
#define NODE_ARR_ACC         1
#define NODE_ARR_TYPE_EXPR   2
#define NODE_ASSGN_STMT      3
#define NODE_BIN_EXPR        4
#define NODE_CALL_STMT       5
#define NODE_COMP_STMT       6
#define NODE_EMPTY_STMT      7
#define NODE_IF_STMT         8
#define NODE_INT_LIT         9
#define NODE_NAMED_TYPE_EXPR 10 
#define NODE_NAMED_VAR       11
#define NODE_PARAM_DECL      12
#define NODE_PARAM_DECL_LIST 13
#define NODE_PROC_DECL       14
#define NODE_STMT_LIST       15
#define NODE_TYPE_DECL       16
#define NODE_UNA_EXPR        17
#define NODE_VAR_DECL        18
#define NODE_VAR_DECL_LIST   19
#define NODE_VAR_EXPR        20
#define NODE_WHILE_STMT      21

#define CURR_TOK_V tokens[tokenPointer + 1]
#define AST_W(n) ast[astPointer] := (n); astPointer := astPointer + 1;

#define NODE(type) AST_W(type)
#define RESERVE_NODE_LENGTH nodeLengthPos := astPointer; AST_W(0) nodeStart := astPointer; 
#define WRITE_NODE_LENGTH ast[nodeLengthPos] := astPointer - nodeStart;
#define EAT_TOKEN(type) parse_eat((type), tokens, tokenPointer);
#define EAT_SEMIC parse_eat(TOK_SEMIC, tokens, tokenPointer);

#define PRINT_AST_IDENT \
        t := ast[astPointer]; \
        astPointer := astPointer + 1; \
        print_array(ast, astPointer, t); \
        astPointer := astPointer + t; \

type DataArray = array[99999] of int;

proc array_cpy(ref source: DataArray, ref target: DataArray, start: int, length: int, startOffset: int) {
    var i: int;

    i := 0;

    while (i < length) {
        target[i + startOffset] := source[start + i];

        i := i + 1;
    }
}

proc print_array(ref source: DataArray, start: int, length: int) {
    var i: int;

    i := 0;

    while (i < length) {
        printc(source[start + i]);

        i := i + 1;
    }
}

proc read_input(ref input: DataArray, ref length: int) {
    var char: int;
    var index: int;

    readc(char);
    input[0] := char;

    index := 1;
    while (char # 0x2E) { // Input file must end with dot (0x2E) to indicate EOF
        readc(char);
        input[index] := char;
        index := index + 1;
    }

    // Replace dot (0x2E) with 0 to indicate EOF
    input[index - 1] := 0;
    length := index - 1;
}

proc lex_is_whitespace(c: int, ref r: int) {
    var space: int;
    var lineFeed: int;
    var carriageReturn: int;
    var horizontalTab: int;

    r := 0;

    if (c = ' ') {
        r := 1;
    }

    if (c = LINE_FEED) {
        r := 1;
    }

    if (c = 0xD) { // Carriage return
        r := 1;
    }

    if (c = 0x9) {
        r := 1;
    }
}

proc lex_is_digit(c: int, ref r: int) {
    r := 0;

    if (c >= 0x30) {
        if (c <= 0x39) {
            r := 1;
        } 
    }
}

proc lex_is_alphanumeric_or_underscore(c: int, ref r: int) {
    r := 0;

    lex_is_digit(c, r);

    if (c >= 0x41) {
        if (c <= 0x5A) {
            r := 1;
        }
    }
    
    if (c >= 0x61) {
        if (c <= 0x7A) {
            r := 1;
        }
    }

    if (c = '_') {
        r := 1;
    }
}

proc lex_hex_to_int(c: int, ref r: int) {
    r := -1;

    if (c >= 'a') {
        if (c <= 'f') {
            r := c - 87;
        }
    }

    if (c >= 'A') {
        if (c <= 'F') {
            r := c - 55;
        }
    }

    if (c >= '0') {
        if (c <= '9') {
            r := CHAR_TO_INT(c);
        } 
    }
}

proc lex_eat_whitespace(ref input: DataArray, ref charPointer: int) {
    var isWhitespace: int;

    lex_is_whitespace(input[charPointer], isWhitespace);

    while (isWhitespace # 0) {
        NEXT_CHAR
        lex_is_whitespace(input[charPointer], isWhitespace);
    }
}

proc lex_eat_comment(ref input: DataArray, ref charPointer: int) {
    var continue: int;

    continue := 1;

    if (input[charPointer] = '/') {
        if (input[charPointer + 1] = '/') {
            while (continue # 0) {
                NEXT_CHAR
                continue := 0;
                if (input[charPointer] # LINE_FEED) {
                    if (input[charPointer] # 0) { // Not EOF
                        continue := 1;
                    }
                }
            }

            lex_eat_whitespace(input, charPointer);
            lex_eat_comment(input, charPointer);
        }
    }
}

proc lex_read_ident(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var startIndex: int;
    var isCurrentCharAlphaOrUnderscore: int;
    var length: int;

    startIndex := charPointer;

    lex_is_alphanumeric_or_underscore(input[charPointer], isCurrentCharAlphaOrUnderscore);

    while (isCurrentCharAlphaOrUnderscore # 0) {
        NEXT_CHAR
        lex_is_alphanumeric_or_underscore(input[charPointer], isCurrentCharAlphaOrUnderscore); 
    }

    length := charPointer - startIndex;

    tokens[tokenPointer] := length;
    tokenPointer := tokenPointer + 1;
    array_cpy(input, tokens, startIndex, length, tokenPointer);
    tokenPointer := tokenPointer + length;

    charPointer := charPointer - 1;
}

proc lex_read_char_lit(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var readChar: int;

    NEXT_CHAR // Skip first single quote

    // 0x5C = backslash
    if (input[charPointer] = 0x5C) { 
        if (input[charPointer + 1] = 'n') {
            NEXT_CHAR
            readChar := '\n';
        } else {
            exit(); // LEXER ERROR: Expected escape sequence
        }
    } else {
        readChar := input[charPointer];
    }

    NEXT_CHAR
    if (input[charPointer] # 0x27) { // 0x27 = ' (single quote)
        exit(); // LEXER ERROR: Expected closing single quote
    }

    tokens[tokenPointer] := readChar;
    tokenPointer := tokenPointer + 1;
}

proc lex_read_decimal_int(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var parsed: int;
    var isDigit: int;

    parsed := CHAR_TO_INT(input[charPointer]);
    
    NEXT_CHAR
    lex_is_digit(input[charPointer], isDigit);

    while (isDigit # 0) {
        parsed := parsed * 10 + CHAR_TO_INT(input[charPointer]);
        NEXT_CHAR
        lex_is_digit(input[charPointer], isDigit); 
    }

    charPointer := charPointer - 1;

    tokens[tokenPointer] := parsed;
    tokenPointer := tokenPointer + 1;
}

proc lex_read_hex_int(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var parsed: int;
    var decimal: int;

    parsed := 0;

    // Skip 0x
    NEXT_CHAR
    NEXT_CHAR

    lex_hex_to_int(input[charPointer], decimal);

    if (decimal = -1) {
        exit(); // LEXER ERROR: Expected number literal
    }

    while (decimal # -1) {
        parsed := parsed * 16 + decimal;
        NEXT_CHAR
        lex_hex_to_int(input[charPointer], decimal);
    }

    charPointer := charPointer - 1;

    tokens[tokenPointer] := parsed;
    tokenPointer := tokenPointer + 1;
}


proc lex_match_keyword(ref input: DataArray, ref charPointer: int, ref keyword: int) {
    var isEnd: int;

    keyword := -1;
    
    K_MATCH(0, 'i') K_MATCH(1, 'f')  {   
        lex_is_alphanumeric_or_underscore(input[charPointer + 2], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 1;
            keyword := TOK_IF;
        }
    }

    K_MATCH(0, 'e') K_MATCH(1, 'l') K_MATCH(2, 's') K_MATCH(3, 'e') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 4], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 3;
            keyword := TOK_ELSE;
        }
    }

    K_MATCH(0, 'w') K_MATCH(1, 'h') K_MATCH(2, 'i') K_MATCH(3, 'l') K_MATCH(4, 'e') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 5], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 4;
            keyword := TOK_WHILE;
        }
    }

    K_MATCH(0, 'a') K_MATCH(1, 'r') K_MATCH(2, 'r') K_MATCH(3, 'a') K_MATCH(4, 'y')  {
        lex_is_alphanumeric_or_underscore(input[charPointer + 5], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 4;
            keyword := TOK_ARRAY;
        }
    }

    K_MATCH(0, 'o') K_MATCH(1, 'f') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 2], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 1;
            keyword := TOK_OF;
        }
    }

    K_MATCH(0, 'p') K_MATCH(1, 'r') K_MATCH(2, 'o') K_MATCH(3, 'c') {     
        lex_is_alphanumeric_or_underscore(input[charPointer + 4], isEnd);
        if (isEnd = 0) {   
            charPointer := charPointer + 3;
            keyword := TOK_PROC;
        }
    }

    K_MATCH(0, 'r') K_MATCH(1, 'e') K_MATCH(2, 'f'){
        lex_is_alphanumeric_or_underscore(input[charPointer + 3], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 2;
            keyword := TOK_REF;
        }
    }

    K_MATCH(0, 't') K_MATCH(1, 'y') K_MATCH(2, 'p') K_MATCH(3, 'e') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 4], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 3;
            keyword := TOK_TYPE;
        }
    }

    K_MATCH(0, 'v') K_MATCH(1, 'a') K_MATCH(2, 'r') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 3], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 2;
            keyword := TOK_VAR;
        }
    }
}

proc lex(ref tokens: DataArray, ref tokenPointer: int, ref input: DataArray, inputLength: int) {
    var charPointer: int;
    var currentChar: int;
    var peekChar: int;
    var isDigit: int;
    var isAlphaOrUnderscore: int;
    var matchedKeyword: int;

    charPointer := 0;
    tokenPointer := 0;

    while (charPointer < inputLength) {
        lex_eat_whitespace(input, charPointer);
        lex_eat_comment(input, charPointer);

        currentChar := input[charPointer];
        peekChar := input[charPointer + 1];

        lex_is_digit(currentChar, isDigit);
        lex_is_alphanumeric_or_underscore(currentChar, isAlphaOrUnderscore);
        
        if (currentChar = ';') {
            TOKEN(TOK_SEMIC)
        } else if (currentChar = ',') {
            TOKEN(TOK_COMMA)
        } else if (currentChar = '(') {
            TOKEN(TOK_LPAREN)
        } else if (currentChar = ')') {
            TOKEN(TOK_RPAREN)
        } else if (currentChar = '{') {
            TOKEN(TOK_LCURL)
        } else if (currentChar = '}') {
            TOKEN(TOK_RCURL)
        } else if (currentChar = '[') {
            TOKEN(TOK_LBRACK)
        } else if (currentChar = ']') {
            TOKEN(TOK_RBRACK)
        } else if (currentChar = '+') {
            TOKEN(TOK_PLUS)
        } else if (currentChar = '-') {
            TOKEN(TOK_MINUS)
        } else if (currentChar = '*') {
            TOKEN(TOK_ASTERISK)
        } else if (currentChar = '/') {
            TOKEN(TOK_SLASH)
        } else if (currentChar = '=') {
            TOKEN(TOK_EQUAL)
        } else if (currentChar = '#') {
            TOKEN(TOK_HASH)
        } else if (currentChar = 0) { // TODO: This should not be necessary but it is
            TOKEN(TOK_EOF)
        } else if (currentChar = ':') {
            if (peekChar = '=') {
                NEXT_CHAR
                TOKEN(TOK_ASSGN)
            } else {
                TOKEN(TOK_COLON)
            }
        } else if (currentChar = '<') {
            if (peekChar = '=') {
                NEXT_CHAR
                TOKEN(TOK_LTE)
            } else {
                TOKEN(TOK_LT)
            }
        } else if (currentChar = '>') {
            if (peekChar = '=') {
                NEXT_CHAR
                TOKEN(TOK_GTE)
            } else {
                TOKEN(TOK_GT)
            }
        } else if (currentChar = 0x27) { // 0x27 = ' (single quote)
            TOKEN(TOK_CHAR)
            lex_read_char_lit(input, charPointer, tokens, tokenPointer);
        } else if (isDigit # 0) {
            TOKEN(TOK_INT)
            if (currentChar = '0') {
                if (peekChar = 'x') {
                    lex_read_hex_int(input, charPointer, tokens, tokenPointer);
                } else {
                    lex_read_decimal_int(input, charPointer, tokens, tokenPointer);
                }
            } else {
                lex_read_decimal_int(input, charPointer, tokens, tokenPointer);
            }
        } else if (isAlphaOrUnderscore # 0) {
            lex_match_keyword(input, charPointer, matchedKeyword);

            if (matchedKeyword # -1) {
                TOKEN(matchedKeyword)
            } else {
                TOKEN(TOK_IDENT)
                lex_read_ident(input, charPointer, tokens, tokenPointer);
            }
        } else {
            TOKEN(TOK_ILLEGAL)
        }

        NEXT_CHAR
    }

    TOKEN(TOK_EOF)
}

proc Lex_print_tokens(ref tokens: DataArray, tokenPointer: int) {
    var head: int;
    var i: int;
    var t: int;

    i := 0;

    while (i < tokenPointer) {
        head := tokens[i];

        if (head = TOK_IDENT) {
            printc('I'); printc('D'); printc('E'); printc('N'); printc('T'); printc(' ');
            i := i + 1;
            t := i + tokens[i];
            while (i < t) {
                printc(tokens[i + 1]);
                i := i + 1;
            }
        } else if (head = TOK_INT) {
            printc('I'); printc('N'); printc('T'); printc(' ');
            printi(tokens[i + 1]);
            i := i + 1;
        } else if (head = TOK_CHAR) {
            printc('C'); printc('H'); printc('A'); printc('R'); printc(' ');
            printc(tokens[i + 1]);
            i := i + 1;
        } else if (head = TOK_IF) {
            printc('I'); printc('F');
        } else if (head = TOK_ELSE) {
            printc('E'); printc('L'); printc('S'); printc('E');
        } else if (head = TOK_WHILE) {
            printc('W'); printc('H'); printc('I'); printc('L'); printc('E');
        } else if (head = TOK_ARRAY) {
            printc('A'); printc('R'); printc('R'); printc('A'); printc('Y');
        } else if (head = TOK_OF) {
            printc('O'); printc('F');
        } else if (head = TOK_PROC) {
            printc('P'); printc('R'); printc('O'); printc('C');
        } else if (head = TOK_REF) {
            printc('R'); printc('E'); printc('F');;
        } else if (head = TOK_TYPE) {
            printc('T'); printc('Y'); printc('P'); printc('E');
        } else if (head = TOK_VAR) {
            printc('V'); printc('A'); printc('R');
        } else if (head = TOK_LPAREN) {
            printc('L'); printc('P'); printc('A'); printc('R'); printc('E'); printc('N');
        } else if (head = TOK_RPAREN) {
            printc('R'); printc('P'); printc('A'); printc('R'); printc('E'); printc('N');
        } else if (head = TOK_LBRACK) {
            printc('L'); printc('B'); printc('R'); printc('A'); printc('C'); printc('K');
        } else if (head = TOK_RBRACK) {
            printc('R'); printc('B'); printc('R'); printc('A'); printc('C'); printc('K');
        } else if (head = TOK_LCURL) {
            printc('L'); printc('C'); printc('U'); printc('R'); printc('L');
        } else if (head = TOK_RCURL) {
            printc('R'); printc('C'); printc('U'); printc('R'); printc('L');
        } else if (head = TOK_EQUAL) {
            printc('E'); printc('Q'); printc('U'); printc('A'); printc('L');
        } else if (head = TOK_HASH) {
            printc('H'); printc('A'); printc('S'); printc('H');
        } else if (head = TOK_LT) {
            printc('L'); printc('T');
        } else if (head = TOK_LTE) {
            printc('L'); printc('T'); printc('E');
        } else if (head = TOK_GT) {
            printc('G'); printc('T');
        } else if (head = TOK_GTE) {
            printc('G'); printc('T'); printc('E');
        } else if (head = TOK_PLUS) {
            printc('P'); printc('L'); printc('U'); printc('S');
        } else if (head = TOK_MINUS) {
            printc('M'); printc('I'); printc('N'); printc('U'); printc('S');
        } else if (head = TOK_ASTERISK) {
            printc('A'); printc('S'); printc('T'); printc('E'); printc('R'); printc('I'); printc('S'); printc('K');
        } else if (head = TOK_SLASH) {
            printc('S'); printc('L'); printc('A'); printc('S'); printc('H');
        } else if (head = TOK_COLON) {
            printc('C'); printc('O'); printc('L'); printc('O'); printc('N');
        } else if (head = TOK_SEMIC) {
            printc('S'); printc('E'); printc('M'); printc('I'); printc('C');
        } else if (head = TOK_COMMA) {
            printc('C'); printc('O'); printc('M'); printc('M'); printc('A');
        } else if (head = TOK_ASSGN) {
            printc('A'); printc('S'); printc('S'); printc('G'); printc('N');
        } else if (head = TOK_EOF) {
            printc('E'); printc('O'); printc('F');
        } else if (head = TOK_ILLEGAL) {
            printc('I'); printc('l'); printc('l'); printc('e'); printc('g'); printc('a'); printc('l');
        }

        printc('\n');

        i := i + 1;
    }
}

proc parse_eat(type_: int, ref tokens: DataArray, ref tokenPointer: int) {
    var length: int;

    if (CURR_TOK = type_) {
        if (type_ = TOK_IDENT) {
            tokenPointer := tokenPointer + 1; // Skip token type
            length := tokens[tokenPointer]; // Ident length
            tokenPointer := tokenPointer + 1; // Skip token length
            tokenPointer := tokenPointer + length; // Skip ident literal
        } else if (type_ = TOK_INT) {
            tokenPointer := tokenPointer + 2; // Skip type and literal
        } else if (type_ = TOK_CHAR) {
            tokenPointer := tokenPointer + 2; // Skip type and literal
        } else {
            tokenPointer := tokenPointer + 1;
        }
    } else {
        exit(); // PARSE ERROR: unexpected token `CURR_TOK`, expected `type` 
    }
}

proc parse_cpy_ident(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var length: int;
    var valueStart: int;

    length := tokens[tokenPointer + 1];
    valueStart := tokenPointer + 2;

    ast[astPointer] := length;
    astPointer := astPointer + 1;
    array_cpy(tokens, ast, valueStart, length, astPointer);

    astPointer := astPointer + length;
}

proc parse_type_expr(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    if (CURR_TOK = TOK_ARRAY) {
        NODE(NODE_ARR_TYPE_EXPR)
        RESERVE_NODE_LENGTH

        EAT_TOKEN(TOK_ARRAY)
        EAT_TOKEN(TOK_LBRACK)

        AST_W(CURR_TOK_V) // Write size to AST
        EAT_TOKEN(TOK_INT)

        EAT_TOKEN(TOK_RBRACK)
        EAT_TOKEN(TOK_OF);

        parse_type_expr(ast, astPointer, tokens, tokenPointer);

        WRITE_NODE_LENGTH
    } else if (CURR_TOK = TOK_IDENT) {
        NODE(NODE_NAMED_TYPE_EXPR)
        RESERVE_NODE_LENGTH

        parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
        EAT_TOKEN(TOK_IDENT)

        WRITE_NODE_LENGTH
    } else {
        exit(); // PARSE ERROR: expected type expression
    }
}

proc parse_type_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_TYPE_DECL)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_TYPE)

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_EQUAL)

    parse_type_expr(ast, astPointer, tokens, tokenPointer);

    EAT_SEMIC

    WRITE_NODE_LENGTH
}

proc parse_param_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_PARAM_DECL)
    RESERVE_NODE_LENGTH

    if (CURR_TOK = TOK_REF) {
        AST_W(1)
        EAT_TOKEN(TOK_REF)
    } else {
        AST_W(0)
    }

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_COLON)

    parse_type_expr(ast, astPointer, tokens, tokenPointer);

    WRITE_NODE_LENGTH
}

proc parse_param_decl_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_PARAM_DECL_LIST)
    RESERVE_NODE_LENGTH

    if (CURR_TOK # TOK_RPAREN) {
        parse_param_decl(ast, astPointer, tokens, tokenPointer);

        while (CURR_TOK = TOK_COMMA) {
            EAT_TOKEN(TOK_COMMA)

            parse_param_decl(ast, astPointer, tokens, tokenPointer);
        }
    }

    WRITE_NODE_LENGTH
}

proc parse_var_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_VAR_DECL)
    RESERVE_NODE_LENGTH 

    EAT_TOKEN(TOK_VAR)
    
    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_COLON)

    parse_type_expr(ast, astPointer, tokens, tokenPointer);

    EAT_SEMIC

    WRITE_NODE_LENGTH
}

proc parse_expr(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    parse_comparison(ast, astPointer, tokens, tokenPointer);
}

proc parse_comparison(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var hasOp: int;
    var nodeLengthPos: int;
    var nodeStart: int;
    var op: int;
    var i: int;

    leftStart := astPointer;
    parse_numeric(ast, astPointer, tokens, tokenPointer);
    leftEnd := astPointer;

    hasOp := 0;
    if (CURR_TOK = TOK_LT) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_LTE) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_GT) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_GTE) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_EQUAL) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_HASH) {
        hasOp := 1;
    }

    if (hasOp # 0) {
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 2] := ast[i];
            i := i - 1;
        }

        ast[leftStart] := NODE_BIN_EXPR;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        nodeStart := leftStart + 2;

        astPointer := leftEnd + 2;

        while (hasOp # 0) {
            op := CURR_TOK;
            AST_W(op);

            if (op = TOK_LT) {
                EAT_TOKEN(TOK_LT)
            } else if (op = TOK_LTE) {
                EAT_TOKEN(TOK_LTE)
            } else if (op = TOK_GT) {
                EAT_TOKEN(TOK_GT)
            } else if (op = TOK_GTE) {
                EAT_TOKEN(TOK_GTE)
            } else if (op = TOK_EQUAL) {
                EAT_TOKEN(TOK_EQUAL)
            } else {
                EAT_TOKEN(TOK_HASH)
            }

            parse_numeric(ast, astPointer, tokens, tokenPointer);

            hasOp := 0;
            if (CURR_TOK = TOK_LT) {
                hasOp := 1;
            }
            if (CURR_TOK = TOK_LTE) {
                hasOp := 1;
            }
            if (CURR_TOK = TOK_GT) {
                hasOp := 1;
            }
            if (CURR_TOK = TOK_GTE) {
                hasOp := 1;
            }
            if (CURR_TOK = TOK_EQUAL) {
                hasOp := 1;
            }
            if (CURR_TOK = TOK_HASH) {
                hasOp := 1;
            }
        }

        ast[nodeLengthPos] := astPointer - nodeStart;
    }
}

proc parse_numeric(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var hasOp: int;
    var nodeLengthPos: int;
    var nodeStart: int;
    var op: int;
    var i: int;

    leftStart := astPointer;
    parse_term(ast, astPointer, tokens, tokenPointer);
    leftEnd := astPointer;

    hasOp := 0;
    if (CURR_TOK = TOK_PLUS) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_MINUS) {
        hasOp := 1;
    }

    if (hasOp # 0) {
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 2] := ast[i];
            i := i - 1;
        }

        ast[leftStart] := NODE_BIN_EXPR;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        nodeStart := leftStart + 2;

        astPointer := leftEnd + 2;

        while (hasOp # 0) {
            op := CURR_TOK;
            AST_W(op);

            if (op = TOK_PLUS) {
                EAT_TOKEN(TOK_PLUS)
            } else {

                EAT_TOKEN(TOK_MINUS)
            }

            parse_term(ast, astPointer, tokens, tokenPointer);

            hasOp := 0;
            if (CURR_TOK = TOK_PLUS) {
                hasOp := 1;
            }
            if (CURR_TOK = TOK_MINUS) {
                hasOp := 1;
            }
        }

        ast[nodeLengthPos] := astPointer - nodeStart;
    }
}

proc parse_term(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var hasOp: int;
    var nodeLengthPos: int;
    var nodeStart: int;
    var op: int;
    var i: int;

    leftStart := astPointer;
    parse_signed_factor(ast, astPointer, tokens, tokenPointer);
    leftEnd := astPointer;

    hasOp := 0;
    if (CURR_TOK = TOK_ASTERISK) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_SLASH) {
        hasOp := 1;
    }

    if (hasOp # 0) {
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 2] := ast[i];
            i := i - 1;
        }

        ast[leftStart] := NODE_BIN_EXPR;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        nodeStart := leftStart + 2;

        astPointer := leftEnd + 2;

        while (hasOp # 0) {
            op := CURR_TOK;
            AST_W(op);

            if (op = TOK_ASTERISK) {
                EAT_TOKEN(TOK_ASTERISK)
            } else {
                EAT_TOKEN(TOK_SLASH)
            }

            parse_signed_factor(ast, astPointer, tokens, tokenPointer);

            hasOp := 0;
            if (CURR_TOK = TOK_ASTERISK) {
                hasOp := 1;
            }
            if (CURR_TOK = TOK_SLASH) {
                hasOp := 1;
            }
        }

        ast[nodeLengthPos] := astPointer - nodeStart;
    }

}

proc parse_signed_factor(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    if (CURR_TOK = TOK_MINUS) {
        NODE(NODE_UNA_EXPR)
        RESERVE_NODE_LENGTH

        AST_W(TOK_MINUS)
        EAT_TOKEN(TOK_MINUS)

        parse_factor(ast, astPointer, tokens, tokenPointer);

        WRITE_NODE_LENGTH
    } else {
        parse_factor(ast, astPointer, tokens, tokenPointer);
    }
}

proc parse_factor(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    if (CURR_TOK = TOK_IDENT) {
        NODE(NODE_VAR_EXPR)
        RESERVE_NODE_LENGTH

        parse_variable(ast, astPointer, tokens, tokenPointer);

        WRITE_NODE_LENGTH
    } else if (CURR_TOK = TOK_INT) {
        NODE(NODE_INT_LIT)
        RESERVE_NODE_LENGTH

        AST_W(CURR_TOK_V)
        EAT_TOKEN(TOK_INT)

        WRITE_NODE_LENGTH
    } else if (CURR_TOK = TOK_CHAR) {
        NODE(NODE_INT_LIT)
        RESERVE_NODE_LENGTH

        AST_W(CURR_TOK_V)
        EAT_TOKEN(TOK_CHAR)

        WRITE_NODE_LENGTH
    } else if (CURR_TOK = TOK_LPAREN) {
        EAT_TOKEN(TOK_LPAREN)
        parse_expr(ast, astPointer, tokens, tokenPointer);
        EAT_TOKEN(TOK_RPAREN)
    } else {
        exit(); // PARSE ERROR: expected expression factor
    }
}

proc parse_variable(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var nodeStart: int;
    var nodeLengthPos: int;
    var i: int;

    leftStart := astPointer;

    NODE(NODE_NAMED_VAR)
    RESERVE_NODE_LENGTH

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    WRITE_NODE_LENGTH

    leftEnd := astPointer;

    while (CURR_TOK = TOK_LBRACK) {
        EAT_TOKEN(TOK_LBRACK)

        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 2] := ast[i];
            i := i - 1;
        }

        ast[leftStart] := NODE_ARR_ACC;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        nodeStart := leftStart + 2;

        astPointer := leftEnd + 2;

        parse_expr(ast, astPointer, tokens, tokenPointer);

        EAT_TOKEN(TOK_RBRACK)

        ast[nodeLengthPos] := astPointer - nodeStart;

        leftEnd := astPointer;
    }
}

proc parse_assgn_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_ASSGN_STMT)
    RESERVE_NODE_LENGTH

    parse_variable(ast, astPointer, tokens, tokenPointer);

    EAT_TOKEN(TOK_ASSGN)

    parse_expr(ast, astPointer, tokens, tokenPointer);

    EAT_SEMIC

    WRITE_NODE_LENGTH 
}

proc parse_if_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_IF_STMT)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_IF)
    EAT_TOKEN(TOK_LPAREN)

    parse_expr(ast, astPointer, tokens, tokenPointer);

    EAT_TOKEN(TOK_RPAREN)

    parse_stmt(ast, astPointer, tokens, tokenPointer);

    if (CURR_TOK = TOK_ELSE) {
        EAT_TOKEN(TOK_ELSE)
        parse_stmt(ast, astPointer, tokens, tokenPointer);
    } else {
        NODE(NODE_EMPTY_STMT)
        RESERVE_NODE_LENGTH
    }

    WRITE_NODE_LENGTH 
}

proc parse_compound_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_COMP_STMT)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_LCURL);
    parse_stmt_list(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_RCURL);

    WRITE_NODE_LENGTH
}

proc parse_while_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_WHILE_STMT)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_WHILE)
    EAT_TOKEN(TOK_LPAREN)

    parse_expr(ast, astPointer, tokens, tokenPointer);

    EAT_TOKEN(TOK_RPAREN)

    parse_stmt(ast, astPointer, tokens, tokenPointer);

    WRITE_NODE_LENGTH 
}

proc parse_empty_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_EMPTY_STMT)
    RESERVE_NODE_LENGTH

    EAT_SEMIC

    WRITE_NODE_LENGTH
}

proc parse_arg_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_ARG_LIST)
    RESERVE_NODE_LENGTH

    if (CURR_TOK # TOK_RPAREN) {
        parse_expr(ast, astPointer, tokens, tokenPointer);

        while (CURR_TOK = TOK_COMMA) {
            EAT_TOKEN(TOK_COMMA)

            parse_expr(ast, astPointer, tokens, tokenPointer);
        }
    }

    WRITE_NODE_LENGTH
}

proc parse_call_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_CALL_STMT)
    RESERVE_NODE_LENGTH

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_LPAREN)
    parse_arg_list(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_RPAREN)

    EAT_SEMIC

    WRITE_NODE_LENGTH
}

proc parse_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    if (CURR_TOK = TOK_IDENT) {
        if (tokens[tokenPointer + tokens[tokenPointer + 1] + 2] = TOK_LPAREN) { // if next token is left paren
            parse_call_stmt(ast, astPointer, tokens, tokenPointer);
        } else {
            parse_assgn_stmt(ast, astPointer, tokens, tokenPointer);
        }
    } else if (CURR_TOK = TOK_IF) {
        parse_if_stmt(ast, astPointer, tokens, tokenPointer);
    } else if (CURR_TOK = TOK_LCURL) {
        parse_compound_stmt(ast, astPointer, tokens, tokenPointer);
    } else if (CURR_TOK = TOK_WHILE) {
        parse_while_stmt(ast, astPointer, tokens, tokenPointer);  
    } else if (CURR_TOK = TOK_SEMIC) {
        parse_empty_stmt(ast, astPointer, tokens, tokenPointer);
    }
}

proc parse_stmt_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    var continue: int;

    NODE(NODE_STMT_LIST)
    RESERVE_NODE_LENGTH

    continue := 0;
    if (CURR_TOK # TOK_RCURL) {
        if (CURR_TOK # TOK_EOF) {
            continue := 1;
        }
    }

    while (continue # 0) {
        parse_stmt(ast, astPointer, tokens, tokenPointer);

        continue := 0;
        if (CURR_TOK # TOK_RCURL) {
            if (CURR_TOK # TOK_EOF) {
                continue := 1;
            }
        }
    }

    WRITE_NODE_LENGTH
}

proc parse_var_decl_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_VAR_DECL_LIST)
    RESERVE_NODE_LENGTH

    while (CURR_TOK = TOK_VAR) {
        parse_var_decl(ast, astPointer, tokens, tokenPointer);
    }

    WRITE_NODE_LENGTH
}

proc parse_proc_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_PROC_DECL)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_PROC)

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_LPAREN)
    parse_param_decl_list(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_RPAREN)

    EAT_TOKEN(TOK_LCURL)

    parse_var_decl_list(ast, astPointer, tokens, tokenPointer);
    parse_stmt_list(ast, astPointer, tokens, tokenPointer);

    EAT_TOKEN(TOK_RCURL)

    WRITE_NODE_LENGTH
}

proc parse_global(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    if (CURR_TOK = TOK_TYPE) {
        parse_type_decl(ast, astPointer, tokens, tokenPointer);
    } else if (CURR_TOK = TOK_PROC) {
        parse_proc_decl(ast, astPointer, tokens, tokenPointer);
    } else {
        exit(); // PARSE ERROR: expected type declaration or procedure declaration
    }
}

proc parse_print_node_type(nodeType: int) {
    if (nodeType = NODE_ARG_LIST) {
        PC('A') PC('R') PC('G') PC('_') PC('L') PC('I') PC('S') PC('T')    
    } else if (nodeType = NODE_ARR_ACC) {
        PC('A') PC('R') PC('R') PC('_') PC('A') PC('C') PC('C');
    } else if (nodeType = NODE_ARR_TYPE_EXPR) {
        PC('A') PC('R') PC('R') PC('_') PC('T') PC('Y') PC('P') PC('E') PC('_') PC('E') PC('X') PC('P') PC('R')
    } else if (nodeType = NODE_ASSGN_STMT) {
        PC('A') PC('S') PC('S'); PC('G') PC('N') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_BIN_EXPR) {
        PC('B') PC('I') PC('N') PC('_') PC('E') PC('X') PC('P') PC('R')
    } else if (nodeType = NODE_CALL_STMT) {
        PC('C') PC('A') PC('L') PC('L') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_COMP_STMT) {
        PC('C') PC('O') PC('M') PC('P') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_EMPTY_STMT) {
        PC('E') PC('M') PC('P') PC('T') PC('Y') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_IF_STMT) {
        PC('I') PC('F') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_INT_LIT) {
        PC('I') PC('N') PC('T') PC('_') PC('L') PC('I') PC('T') 
    } else if (nodeType = NODE_NAMED_TYPE_EXPR) {
        PC('N') PC('A') PC('M'); PC('E') PC('D') PC('_') PC('T') PC('Y') PC('P') PC('E') PC('_') PC('E') PC('X') PC('P') PC('R')
    } else if (nodeType = NODE_NAMED_VAR) {
        PC('N') PC('A') PC('M'); PC('E') PC('D') PC('_') PC('V') PC('A') PC('R')
    } else if (nodeType = NODE_PARAM_DECL) {
        PC('P') PC('A') PC('R') PC('A') PC('M') PC('_') PC('D') PC('E') PC('C') PC('L')
    } else if (nodeType = NODE_PARAM_DECL_LIST) {
        PC('P') PC('A') PC('R') PC('A') PC('M') PC('_') PC('D') PC('E') PC('C') PC('L') PC('_') PC('L') PC('I') PC('S') PC('T')      
    } else if (nodeType = NODE_PROC_DECL) {
        PC('P') PC('R') PC('O') PC('C') PC('_') PC('D') PC('E') PC('C') PC('L')           
    } else if (nodeType = NODE_STMT_LIST) {
        PC('S') PC('T') PC('M') PC('T') PC('_') PC('L') PC('I') PC('S') PC('T')           
    } else if (nodeType = NODE_TYPE_DECL) {
        PC('T') PC('Y') PC('P') PC('E') PC('_') PC('D') PC('E') PC('C') PC('L')           
    } else if (nodeType = NODE_UNA_EXPR) {
        PC('U') PC('N') PC('A') PC('_') PC('E') PC('X') PC('P') PC('R')    
    } else if (nodeType = NODE_VAR_DECL) {
        PC('V') PC('A') PC('R') PC('_') PC('D') PC('E') PC('C') PC('L')        
    } else if (nodeType = NODE_VAR_DECL_LIST) {
        PC('V') PC('A') PC('R') PC('_') PC('D') PC('E') PC('C') PC('L') PC('_') PC('L') PC('I') PC('S') PC('T')         
    } else if (nodeType = NODE_VAR_EXPR) {
        PC('V') PC('A') PC('R') PC('_') PC('E') PC('X') PC('P') PC('R')    
    } else if (nodeType = NODE_WHILE_STMT) {
        PC('W') PC('H') PC('I') PC('L') PC('E') PC('_') PC('S') PC('T') PC('M') PC('T')       
    }
}

proc parse_print_list(ref ast: DataArray, ref astPointer: int, nodeType: int) {
    while (ast[astPointer] = nodeType) {
        parse_print_ast(ast, astPointer);

        if (ast[astPointer] = nodeType) {
            printc(','); printc(' ');
        }
    }
}

proc parse_print_ast(ref ast: DataArray, ref astPointer: int) {
    var nodeType: int;
    var nodeLength: int;
    var t: int;

    nodeType := ast[astPointer];
    astPointer := astPointer + 1;

    nodeLength := ast[astPointer];
    astPointer := astPointer + 1;

    printc('(');
    parse_print_node_type(nodeType);
    printc(' ');

    if (nodeType = NODE_TYPE_DECL) {
        PRINT_AST_IDENT

        printc(' ');

        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_NAMED_TYPE_EXPR) {
        PRINT_AST_IDENT
    } else if (nodeType = NODE_ARR_TYPE_EXPR) {
        printi(ast[astPointer]); // Size
        astPointer := astPointer + 1;

        printc(' ');

        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_PROC_DECL) {
        PRINT_AST_IDENT
        printc(' ');
        parse_print_ast(ast, astPointer);
        printc(' ');
        parse_print_ast(ast, astPointer);
        printc(' ');
        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_PARAM_DECL_LIST) {
        parse_print_list(ast, astPointer, NODE_PARAM_DECL);
    } else if (nodeType = NODE_PARAM_DECL) {
        printi(ast[astPointer]);
        astPointer := astPointer + 1;
        printc(' ');
        PRINT_AST_IDENT
        printc(' ');
        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_VAR_DECL_LIST) {
        parse_print_list(ast, astPointer, NODE_VAR_DECL);  
    } else if (nodeType = NODE_VAR_DECL) {
        PRINT_AST_IDENT
        printc(' ');
        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_STMT_LIST) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            parse_print_ast(ast, astPointer);
            if (astPointer < t + nodeLength) {
                printc(',');
                printc(' ');
            }
        }
    } else if (nodeType = NODE_ASSGN_STMT) {
        parse_print_ast(ast, astPointer);
        printc(' ');
        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_NAMED_VAR) {
        PRINT_AST_IDENT
    } else if (nodeType = NODE_INT_LIT) {
        printi(ast[astPointer]);
        astPointer := astPointer + 1;
    } else if (nodeType = NODE_BIN_EXPR) {
        parse_print_ast(ast, astPointer);
        printc(' ');
        t := ast[astPointer]; // Operator
        if (t = TOK_EQUAL) {
            printc('=');
        } else if (t = TOK_HASH) {
            printc('#');
        } else if (t = TOK_LT) {
            printc('<');
        } else if (t = TOK_LTE) {
            printc('<'); printc('=');
        } else if (t = TOK_GT) {
            printc('>');
        } else if (t = TOK_GTE) {
            printc('>'); printc('=');
        } else if (t = TOK_PLUS) {
            printc('+');
        } else if (t = TOK_MINUS) {
            printc('-');
        } else if (t = TOK_ASTERISK) {
            printc('*');
        } else if (t = TOK_SLASH) {
            printc('/');
        }
        astPointer := astPointer + 1;
        printc(' ');
        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_ARR_ACC) {
        parse_print_ast(ast, astPointer);
        printc(' ');
        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_IF_STMT) {
        parse_print_ast(ast, astPointer);
        printc(' ');
        parse_print_ast(ast, astPointer);
        printc(' ');
        parse_print_ast(ast, astPointer);
        printc(' ');
    } else if (nodeType = NODE_COMP_STMT) {
        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_WHILE_STMT) {
        parse_print_ast(ast, astPointer);
        printc(' ');
        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_CALL_STMT) {
        PRINT_AST_IDENT
        printc(' ');
        parse_print_ast(ast, astPointer);      
    } else if (nodeType = NODE_ARG_LIST) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            parse_print_ast(ast, astPointer);
            if (astPointer < t + nodeLength) {
                printc(',');
                printc(' ');
            }
        }
    } else if (nodeType = NODE_UNA_EXPR) {
        t := ast[astPointer]; // Operator 
        astPointer := astPointer + 1;
        if (t = TOK_MINUS) {
            printc('-');
        }
        printc(' ');
        parse_print_ast(ast, astPointer);
    } else if (nodeType = NODE_VAR_EXPR) {
        parse_print_ast(ast, astPointer);   
    }

    printc(')');
}

proc parse(ref ast: DataArray, ref tokens: DataArray) {
    var nodeStart: int;
    var nodeLengthPos: int;
    var astPointer: int;
    var tokenPointer: int;

    astPointer := 0;
    tokenPointer := 0;

    NODE(NODE_STMT_LIST)
    RESERVE_NODE_LENGTH

    while (CURR_TOK # TOK_EOF) {
        parse_global(ast, astPointer, tokens, tokenPointer);
    }

    WRITE_NODE_LENGTH
}

proc main() {
    var i: int;
    var t: int;

    var input: DataArray;
    var inputLength: int;
    var tokenPointer: int;
    var tokens: DataArray;
    var ast: DataArray;

    read_input(input, inputLength);

    lex(tokens, tokenPointer, input, inputLength);

    //Lex_print_tokens(tokens, tokenPointer);
    parse(ast, tokens);

    i := 0;
    while (i < 30) {
        //printi(ast[i]);
        //printc('\n');
        i := i + 1;
    }

    t := 0;
    parse_print_ast(ast, t);
    printc('\n');
}