#define LINE_FEED 10
#define HASHMAP_SIZE 2048
#define HASHMAP_KEY_SIZE 64
#define MAX_SYMBOL_TABLES 128

#define PC(x) printc(x);

#define TOK_IDENT    0
#define TOK_INT      1
#define TOK_IF       2
#define TOK_ELSE     3
#define TOK_WHILE    4
#define TOK_ARRAY    5
#define TOK_OF       6
#define TOK_PROC     7
#define TOK_REF      8
#define TOK_TYPE     9
#define TOK_VAR      10
#define TOK_LPAREN   11
#define TOK_RPAREN   12
#define TOK_LBRACK   13
#define TOK_RBRACK   14
#define TOK_LCURL    15
#define TOK_RCURL    16
#define TOK_EQUAL    17
#define TOK_HASH     18
#define TOK_LT       19
#define TOK_LTE      20
#define TOK_GT       21
#define TOK_GTE      22
#define TOK_PLUS     23
#define TOK_MINUS    24
#define TOK_ASTERISK 25
#define TOK_SLASH    26
#define TOK_COLON    27
#define TOK_SEMIC    28
#define TOK_COMMA    29
#define TOK_ASSGN    30
#define TOK_EOF      31
#define TOK_ILLEGAL  32

#define NEXT_CHAR charPointer := charPointer + 1;
#define TOKEN(type) tokens[tokenPointer] := type; tokenPointer := tokenPointer + 1;
#define K_MATCH(i, c) if (input[charPointer + (i)] = c)

#define CURR_TOK tokens[tokenPointer]

#define CHAR_TO_INT(c) ((c) - 0x30)

#define NODE_ARG_LIST        0
#define NODE_ARR_ACC         1
#define NODE_ARR_TYPE_EXPR   2
#define NODE_ASSGN_STMT      3
#define NODE_BIN_EXPR        4
#define NODE_CALL_STMT       5
#define NODE_COMP_STMT       6
#define NODE_EMPTY_STMT      7
#define NODE_IF_STMT         8
#define NODE_INT_LIT         9
#define NODE_NAMED_TYPE_EXPR 10 
#define NODE_NAMED_VAR       11
#define NODE_PARAM_DECL      12
#define NODE_PARAM_DECL_LIST 13
#define NODE_PROC_DECL       14
#define NODE_STMT_LIST       15
#define NODE_TYPE_DECL       16
#define NODE_UNA_EXPR        17
#define NODE_VAR_DECL        18
#define NODE_VAR_DECL_LIST   19
#define NODE_VAR_EXPR        20
#define NODE_WHILE_STMT      21

#define CURR_TOK_V tokens[tokenPointer + 1]
#define AST_W(n) ast[astPointer] := (n); astPointer := astPointer + 1;

#define NODE(type) AST_W(type)
#define RESERVE_NODE_LENGTH nodeLengthPos := astPointer; AST_W(0) nodeStart := astPointer; 
#define WRITE_NODE_LENGTH ast[nodeLengthPos] := astPointer - nodeStart;
#define EAT_TOKEN(type) parse_eat((type), tokens, tokenPointer);
#define EAT_SEMIC parse_eat(TOK_SEMIC, tokens, tokenPointer);

#define PRINT_AST_IDENT \
        t := ast[astPointer]; \
        astPointer := astPointer + 1; \
        print_array(ast, astPointer, t); \
        astPointer := astPointer + t; \

#define HASH_KEY_START(h) h[0]
#define HASH_KEY_LEN(h) h[1]
#define HASH_VAL(h) h[2]
#define HASH_USED(h) h[3]
#define HASH_POOL(h) h[4]

#define GLOBAL_TABLE symbolTables[0]
#define CURRENT_TABLE symbolTables[tablePointer]

#define SYM_TAB_ENTRY_PROC 0
#define SYM_TAB_ENTRY_TYPE 1
#define SYM_TAB_ENTRY_VAR  2

#define ENTRIES_W(v) entries[entryPointer] := v; entryPointer := entryPointer + 1;

#define SPL_TYPE_ARRAY 0
#define SPL_TYPE_INT   1
#define SPL_TYPE_BOOL  2
#define SPL_TYPE_REF   3 // A reference to type stored at another position in the entries array. Used for array sub types

#define SPL_TYPE_INT_INDEX 2 // This is the index at which the int type is stored in the entries array. It is important to update it if the table initialization order changes!!
#define SPL_TYPE_BOOL_INDEX 0

#define SKIP_NODE astPointer := astPointer + 1 + 1 + ast[astPointer + 1];

#define REG_RDI 0
#define REG_RSI 1
#define REG_RDX 2
#define REG_RCX 3
#define REG_R8  4
#define REG_R9  5
#define REG_RBP 6
#define REG_RSP 7

#define WORD_SIZE 8

#define CURR_PARAM_POSITION entries[procEntryIndex + 3 + currParamIndex + 1]
#define CURR_PARAM_OFFSET entries[procEntryIndex + 3 + currParamIndex + 2]
#define STACK_LAYOUT_LOCAL_VAR_AREA_SIZE entries[procEntryIndex + 3 + paramCount * 5]
#define STACK_LAYOUT_ARG_AREA_SIZE entries[procEntryIndex + 3 + paramCount * 5 + 1]
#define VAR_ENTRY_POSITION entries[varEntryIndex + 4]
#define VAR_ENTRY_OFFSET entries[varEntryIndex + 5]
#define VAR_ENTRY_TYPE_INDEX varEntryIndex + 2

#define STACK_LAYOUT_OUT_AREA_SIZE entries[procEntryIndex + 3 + paramCount * 5 + 2]

type DataArray = array[99999] of int;

type HashMapKeyBuffer = array[HASHMAP_KEY_SIZE] of int;
type HashMapComponent = array[HASHMAP_SIZE] of int;
type HashMap = array[5] of HashMapComponent;

type SymbolTables = array[MAX_SYMBOL_TABLES] of HashMap;

proc hash_string(ref data: HashMapKeyBuffer, length: int, ref result: int) {
    var h: int;
    var i: int;
    var c: int;

    h := 0;
    i := 0;
    while (i < length) {
        c := data[i];

        h := h * 31 + c;

        while (h >= HASHMAP_SIZE) {
            h := h - HASHMAP_SIZE;
        }

        i := i + 1;
    }

    result := h;
}

proc string_equals_buf_pool(
    ref buf: HashMapKeyBuffer, // external buffer
    len1: int,        // slice in buf (0 - len)
    ref pool: HashMapComponent,
    s2: int, len2: int,        // slice in pool (stored key)
    ref result: int
) {
    var i: int;
    var c1: int;
    var c2: int;

    result := 0;

    if (len1 = len2) {
        i := 0;
        result := 1;
        while (i < len1) {
            c1 := buf[i];
            c2 := pool[s2 + i + 1];   // +1 because pool[0] is the pool pointer
            if (c1 # c2) {
                result := 0;
                i := len1; 
            } else {
                i := i + 1;
            }
        }
    }
}

proc hashmap_cpy_key(ref source: DataArray, ref target: HashMapKeyBuffer, start: int, length: int) {
    var i: int;

    i := 0;
    while (i < length) {
        target[i] := source[start + i];
        i := i + 1;
    }
}

proc hashmap_init(ref map: HashMap) {
    var i: int;

    HASH_POOL(map)[0] := 1;   // first element is "next free" pointer

    i := 0;
    while (i < HASHMAP_SIZE) {
        HASH_USED(map)[i] := 0;
        i := i + 1;
    }
}

proc hashmap_put_str(
    ref map: HashMap,
    ref keyBuf: HashMapKeyBuffer,
    keyLen: int,
    value: int
) {
    var h: int;
    var idx: int;
    var i: int;
    var eq: int;
    var poolPos: int;
    var j: int;

    hash_string(keyBuf, keyLen, h);
    idx := h;

    i := 0;
    while (i < HASHMAP_SIZE) {
        if (HASH_USED(map)[idx] = 0) {
            poolPos := HASH_POOL(map)[0]; 
            j := 0;
            while (j < keyLen) {
                HASH_POOL(map)[poolPos + j] := keyBuf[j];
                j := j + 1;
            }
            HASH_POOL(map)[0] := poolPos + keyLen;

            HASH_USED(map)[idx] := 1;
            HASH_KEY_START(map)[idx] := poolPos - 1;  // minus 1 because pool is offset by 1 in equals
            HASH_KEY_LEN(map)[idx] := keyLen;
            HASH_VAL(map)[idx] := value;

            i := HASHMAP_SIZE;               // break
        } else {
            // check if same key: compare external buf vs stored pool copy
            string_equals_buf_pool(
                keyBuf, keyLen,
                HASH_POOL(map),
                HASH_KEY_START(map)[idx], HASH_KEY_LEN(map)[idx],
                eq
            );
            if (eq # 0) {
                // same key, update value
                HASH_VAL(map)[idx] := value;
                i := HASHMAP_SIZE;           // break
            } else {
                idx := idx + 1;
                if (idx = HASHMAP_SIZE) {
                    idx := 0;
                }
                i := i + 1;
            }
        }
    }

    // TODO: handle full table
}

proc hashmap_get_str(
    ref map: HashMap,
    ref keyBuf: HashMapKeyBuffer,
    keyLen: int,
    ref found: int,
    ref result: int
) {
    var h: int;
    var idx: int;
    var i: int;
    var eq: int;

    // hash from external buffer
    hash_string(keyBuf, keyLen, h);
    idx := h;

    found := 0;
    i := 0;
    while (i < HASHMAP_SIZE) {
        if (HASH_USED(map)[idx] = 0) {
            // empty slot: not present
            i := HASHMAP_SIZE;       // break
        } else {
            string_equals_buf_pool(
                keyBuf, keyLen,
                HASH_POOL(map),
                HASH_KEY_START(map)[idx], HASH_KEY_LEN(map)[idx],
                eq
            );
            if (eq # 0) {
                found := 1;
                result := HASH_VAL(map)[idx];
                i := HASHMAP_SIZE;   // break
            } else {
                idx := idx + 1;
                if (idx = HASHMAP_SIZE) {
                    idx := 0;
                }
                i := i + 1;
            }
        }
    }
}

proc array_cpy(ref source: DataArray, ref target: DataArray, start: int, length: int, startOffset: int) {
    var i: int;

    i := 0;

    while (i < length) {
        target[i + startOffset] := source[start + i];

        i := i + 1;
    }
}

proc print_array(ref source: DataArray, start: int, length: int) {
    var i: int;

    i := 0;

    while (i < length) {
        printc(source[start + i]);

        i := i + 1;
    }
}

proc read_input(ref input: DataArray, ref length: int) {
    var char: int;
    var index: int;

    readc(char);
    input[0] := char;

    index := 1;
    while (char # 0x2E) { // Input file must end with dot (0x2E) to indicate EOF
        readc(char);
        input[index] := char;
        index := index + 1;
    }

    // Replace dot (0x2E) with 0 to indicate EOF
    input[index - 1] := 0;
    length := index - 1;
}

proc lex_is_whitespace(c: int, ref r: int) {
    var space: int;
    var lineFeed: int;
    var carriageReturn: int;
    var horizontalTab: int;

    r := 0;

    if (c = ' ') {
        r := 1;
    }

    if (c = LINE_FEED) {
        r := 1;
    }

    if (c = 0xD) { // Carriage return
        r := 1;
    }

    if (c = 0x9) {
        r := 1;
    }
}

proc lex_is_digit(c: int, ref r: int) {
    r := 0;

    if (c >= 0x30) {
        if (c <= 0x39) {
            r := 1;
        } 
    }
}

proc lex_is_alphanumeric_or_underscore(c: int, ref r: int) {
    r := 0;

    lex_is_digit(c, r);

    if (c >= 0x41) {
        if (c <= 0x5A) {
            r := 1;
        }
    }
    
    if (c >= 0x61) {
        if (c <= 0x7A) {
            r := 1;
        }
    }

    if (c = '_') {
        r := 1;
    }
}

proc lex_hex_to_int(c: int, ref r: int) {
    r := -1;

    if (c >= 'a') {
        if (c <= 'f') {
            r := c - 87;
        }
    }

    if (c >= 'A') {
        if (c <= 'F') {
            r := c - 55;
        }
    }

    if (c >= '0') {
        if (c <= '9') {
            r := CHAR_TO_INT(c);
        } 
    }
}

proc lex_eat_whitespace(ref input: DataArray, ref charPointer: int) {
    var isWhitespace: int;

    lex_is_whitespace(input[charPointer], isWhitespace);

    while (isWhitespace # 0) {
        NEXT_CHAR
        lex_is_whitespace(input[charPointer], isWhitespace);
    }
}

proc lex_eat_comment(ref input: DataArray, ref charPointer: int) {
    var continue: int;

    continue := 1;

    if (input[charPointer] = '/') {
        if (input[charPointer + 1] = '/') {
            while (continue # 0) {
                NEXT_CHAR
                continue := 0;
                if (input[charPointer] # LINE_FEED) {
                    if (input[charPointer] # 0) { // Not EOF
                        continue := 1;
                    }
                }
            }

            lex_eat_whitespace(input, charPointer);
            lex_eat_comment(input, charPointer);
        }
    }
}

proc lex_read_ident(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var startIndex: int;
    var isCurrentCharAlphaOrUnderscore: int;
    var length: int;

    startIndex := charPointer;

    lex_is_alphanumeric_or_underscore(input[charPointer], isCurrentCharAlphaOrUnderscore);

    while (isCurrentCharAlphaOrUnderscore # 0) {
        NEXT_CHAR
        lex_is_alphanumeric_or_underscore(input[charPointer], isCurrentCharAlphaOrUnderscore); 
    }

    length := charPointer - startIndex;

    tokens[tokenPointer] := length;
    tokenPointer := tokenPointer + 1;
    array_cpy(input, tokens, startIndex, length, tokenPointer);
    tokenPointer := tokenPointer + length;

    charPointer := charPointer - 1;
}

proc lex_read_char_lit(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var readChar: int;

    NEXT_CHAR // Skip first single quote

    // 0x5C = backslash
    if (input[charPointer] = 0x5C) { 
        if (input[charPointer + 1] = 'n') {
            NEXT_CHAR
            readChar := '\n';
        } else {
            readChar := 0x5C; // backslash character
        }
    } else {
        readChar := input[charPointer];
    }

    NEXT_CHAR
    if (input[charPointer] # 0x27) { // 0x27 = ' (single quote)
        exit(); // LEXER ERROR: Expected closing single quote
    }

    tokens[tokenPointer] := readChar;
    tokenPointer := tokenPointer + 1;
}

proc lex_read_decimal_int(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var parsed: int;
    var isDigit: int;

    parsed := CHAR_TO_INT(input[charPointer]);
    
    NEXT_CHAR
    lex_is_digit(input[charPointer], isDigit);

    while (isDigit # 0) {
        parsed := parsed * 10 + CHAR_TO_INT(input[charPointer]);
        NEXT_CHAR
        lex_is_digit(input[charPointer], isDigit); 
    }

    charPointer := charPointer - 1;

    tokens[tokenPointer] := parsed;
    tokenPointer := tokenPointer + 1;
}

proc lex_read_hex_int(ref input: DataArray, ref charPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var parsed: int;
    var decimal: int;

    parsed := 0;

    // Skip 0x
    NEXT_CHAR
    NEXT_CHAR

    lex_hex_to_int(input[charPointer], decimal);

    if (decimal = -1) {
        exit(); // LEXER ERROR: Expected number literal
    }

    while (decimal # -1) {
        parsed := parsed * 16 + decimal;
        NEXT_CHAR
        lex_hex_to_int(input[charPointer], decimal);
    }

    charPointer := charPointer - 1;

    tokens[tokenPointer] := parsed;
    tokenPointer := tokenPointer + 1;
}


proc lex_match_keyword(ref input: DataArray, ref charPointer: int, ref keyword: int) {
    var isEnd: int;

    keyword := -1;
    
    K_MATCH(0, 'i') K_MATCH(1, 'f')  {   
        lex_is_alphanumeric_or_underscore(input[charPointer + 2], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 1;
            keyword := TOK_IF;
        }
    }

    K_MATCH(0, 'e') K_MATCH(1, 'l') K_MATCH(2, 's') K_MATCH(3, 'e') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 4], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 3;
            keyword := TOK_ELSE;
        }
    }

    K_MATCH(0, 'w') K_MATCH(1, 'h') K_MATCH(2, 'i') K_MATCH(3, 'l') K_MATCH(4, 'e') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 5], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 4;
            keyword := TOK_WHILE;
        }
    }

    K_MATCH(0, 'a') K_MATCH(1, 'r') K_MATCH(2, 'r') K_MATCH(3, 'a') K_MATCH(4, 'y')  {
        lex_is_alphanumeric_or_underscore(input[charPointer + 5], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 4;
            keyword := TOK_ARRAY;
        }
    }

    K_MATCH(0, 'o') K_MATCH(1, 'f') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 2], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 1;
            keyword := TOK_OF;
        }
    }

    K_MATCH(0, 'p') K_MATCH(1, 'r') K_MATCH(2, 'o') K_MATCH(3, 'c') {     
        lex_is_alphanumeric_or_underscore(input[charPointer + 4], isEnd);
        if (isEnd = 0) {   
            charPointer := charPointer + 3;
            keyword := TOK_PROC;
        }
    }

    K_MATCH(0, 'r') K_MATCH(1, 'e') K_MATCH(2, 'f'){
        lex_is_alphanumeric_or_underscore(input[charPointer + 3], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 2;
            keyword := TOK_REF;
        }
    }

    K_MATCH(0, 't') K_MATCH(1, 'y') K_MATCH(2, 'p') K_MATCH(3, 'e') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 4], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 3;
            keyword := TOK_TYPE;
        }
    }

    K_MATCH(0, 'v') K_MATCH(1, 'a') K_MATCH(2, 'r') {
        lex_is_alphanumeric_or_underscore(input[charPointer + 3], isEnd);
        if (isEnd = 0) {
            charPointer := charPointer + 2;
            keyword := TOK_VAR;
        }
    }
}

proc lex(ref tokens: DataArray, ref tokenPointer: int, ref input: DataArray, inputLength: int) {
    var charPointer: int;
    var currentChar: int;
    var peekChar: int;
    var isDigit: int;
    var isAlphaOrUnderscore: int;
    var matchedKeyword: int;

    charPointer := 0;
    tokenPointer := 0;

    while (charPointer < inputLength) {
        lex_eat_whitespace(input, charPointer);
        lex_eat_comment(input, charPointer);

        currentChar := input[charPointer];
        peekChar := input[charPointer + 1];

        lex_is_digit(currentChar, isDigit);
        lex_is_alphanumeric_or_underscore(currentChar, isAlphaOrUnderscore);
        
        if (currentChar = ';') {
            TOKEN(TOK_SEMIC)
        } else if (currentChar = ',') {
            TOKEN(TOK_COMMA)
        } else if (currentChar = '(') {
            TOKEN(TOK_LPAREN)
        } else if (currentChar = ')') {
            TOKEN(TOK_RPAREN)
        } else if (currentChar = '{') {
            TOKEN(TOK_LCURL)
        } else if (currentChar = '}') {
            TOKEN(TOK_RCURL)
        } else if (currentChar = '[') {
            TOKEN(TOK_LBRACK)
        } else if (currentChar = ']') {
            TOKEN(TOK_RBRACK)
        } else if (currentChar = '+') {
            TOKEN(TOK_PLUS)
        } else if (currentChar = '-') {
            TOKEN(TOK_MINUS)
        } else if (currentChar = '*') {
            TOKEN(TOK_ASTERISK)
        } else if (currentChar = '/') {
            TOKEN(TOK_SLASH)
        } else if (currentChar = '=') {
            TOKEN(TOK_EQUAL)
        } else if (currentChar = '#') {
            TOKEN(TOK_HASH)
        } else if (currentChar = 0) { // TODO: This should not be necessary but it is
            TOKEN(TOK_EOF)
        } else if (currentChar = ':') {
            if (peekChar = '=') {
                NEXT_CHAR
                TOKEN(TOK_ASSGN)
            } else {
                TOKEN(TOK_COLON)
            }
        } else if (currentChar = '<') {
            if (peekChar = '=') {
                NEXT_CHAR
                TOKEN(TOK_LTE)
            } else {
                TOKEN(TOK_LT)
            }
        } else if (currentChar = '>') {
            if (peekChar = '=') {
                NEXT_CHAR
                TOKEN(TOK_GTE)
            } else {
                TOKEN(TOK_GT)
            }
        } else if (currentChar = 0x27) { // 0x27 = ' (single quote)
            TOKEN(TOK_INT)
            lex_read_char_lit(input, charPointer, tokens, tokenPointer);
        } else if (isDigit # 0) {
            TOKEN(TOK_INT)
            if (currentChar = '0') {
                if (peekChar = 'x') {
                    lex_read_hex_int(input, charPointer, tokens, tokenPointer);
                } else {
                    lex_read_decimal_int(input, charPointer, tokens, tokenPointer);
                }
            } else {
                lex_read_decimal_int(input, charPointer, tokens, tokenPointer);
            }
        } else if (isAlphaOrUnderscore # 0) {
            lex_match_keyword(input, charPointer, matchedKeyword);

            if (matchedKeyword # -1) {
                TOKEN(matchedKeyword)
            } else {
                TOKEN(TOK_IDENT)
                lex_read_ident(input, charPointer, tokens, tokenPointer);
            }
        } else {
            TOKEN(TOK_ILLEGAL)
        }

        NEXT_CHAR
    }

    TOKEN(TOK_EOF)
}

proc lex_print_tokens(ref tokens: DataArray, tokenPointer: int) {
    var head: int;
    var i: int;
    var t: int;

    i := 0;

    while (i < tokenPointer) {
        head := tokens[i];

        if (head = TOK_IDENT) {
            printc('I'); printc('D'); printc('E'); printc('N'); printc('T'); printc(' ');
            i := i + 1;
            t := i + tokens[i];
            while (i < t) {
                printc(tokens[i + 1]);
                i := i + 1;
            }
        } else if (head = TOK_INT) {
            printc('I'); printc('N'); printc('T'); printc(' ');
            printi(tokens[i + 1]);
            i := i + 1;
        } else if (head = TOK_IF) {
            printc('I'); printc('F');
        } else if (head = TOK_ELSE) {
            printc('E'); printc('L'); printc('S'); printc('E');
        } else if (head = TOK_WHILE) {
            printc('W'); printc('H'); printc('I'); printc('L'); printc('E');
        } else if (head = TOK_ARRAY) {
            printc('A'); printc('R'); printc('R'); printc('A'); printc('Y');
        } else if (head = TOK_OF) {
            printc('O'); printc('F');
        } else if (head = TOK_PROC) {
            printc('P'); printc('R'); printc('O'); printc('C');
        } else if (head = TOK_REF) {
            printc('R'); printc('E'); printc('F');;
        } else if (head = TOK_TYPE) {
            printc('T'); printc('Y'); printc('P'); printc('E');
        } else if (head = TOK_VAR) {
            printc('V'); printc('A'); printc('R');
        } else if (head = TOK_LPAREN) {
            printc('L'); printc('P'); printc('A'); printc('R'); printc('E'); printc('N');
        } else if (head = TOK_RPAREN) {
            printc('R'); printc('P'); printc('A'); printc('R'); printc('E'); printc('N');
        } else if (head = TOK_LBRACK) {
            printc('L'); printc('B'); printc('R'); printc('A'); printc('C'); printc('K');
        } else if (head = TOK_RBRACK) {
            printc('R'); printc('B'); printc('R'); printc('A'); printc('C'); printc('K');
        } else if (head = TOK_LCURL) {
            printc('L'); printc('C'); printc('U'); printc('R'); printc('L');
        } else if (head = TOK_RCURL) {
            printc('R'); printc('C'); printc('U'); printc('R'); printc('L');
        } else if (head = TOK_EQUAL) {
            printc('E'); printc('Q'); printc('U'); printc('A'); printc('L');
        } else if (head = TOK_HASH) {
            printc('H'); printc('A'); printc('S'); printc('H');
        } else if (head = TOK_LT) {
            printc('L'); printc('T');
        } else if (head = TOK_LTE) {
            printc('L'); printc('T'); printc('E');
        } else if (head = TOK_GT) {
            printc('G'); printc('T');
        } else if (head = TOK_GTE) {
            printc('G'); printc('T'); printc('E');
        } else if (head = TOK_PLUS) {
            printc('P'); printc('L'); printc('U'); printc('S');
        } else if (head = TOK_MINUS) {
            printc('M'); printc('I'); printc('N'); printc('U'); printc('S');
        } else if (head = TOK_ASTERISK) {
            printc('A'); printc('S'); printc('T'); printc('E'); printc('R'); printc('I'); printc('S'); printc('K');
        } else if (head = TOK_SLASH) {
            printc('S'); printc('L'); printc('A'); printc('S'); printc('H');
        } else if (head = TOK_COLON) {
            printc('C'); printc('O'); printc('L'); printc('O'); printc('N');
        } else if (head = TOK_SEMIC) {
            printc('S'); printc('E'); printc('M'); printc('I'); printc('C');
        } else if (head = TOK_COMMA) {
            printc('C'); printc('O'); printc('M'); printc('M'); printc('A');
        } else if (head = TOK_ASSGN) {
            printc('A'); printc('S'); printc('S'); printc('G'); printc('N');
        } else if (head = TOK_EOF) {
            printc('E'); printc('O'); printc('F');
        } else if (head = TOK_ILLEGAL) {
            printc('I'); printc('l'); printc('l'); printc('e'); printc('g'); printc('a'); printc('l');
        }

        printc('\n');

        i := i + 1;
    }
}

proc parse_eat(type_: int, ref tokens: DataArray, ref tokenPointer: int) {
    var length: int;

    if (CURR_TOK = type_) {
        if (type_ = TOK_IDENT) {
            tokenPointer := tokenPointer + 1; // Skip token type
            length := tokens[tokenPointer]; // Ident length
            tokenPointer := tokenPointer + 1; // Skip token length
            tokenPointer := tokenPointer + length; // Skip ident literal
        } else if (type_ = TOK_INT) {
            tokenPointer := tokenPointer + 2; // Skip type and literal
        } else {
            tokenPointer := tokenPointer + 1;
        }
    } else {
        exit(); // PARSE ERROR: unexpected token `CURR_TOK`, expected `type` 
    }
}

proc parse_cpy_ident(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var length: int;
    var valueStart: int;

    length := tokens[tokenPointer + 1];
    valueStart := tokenPointer + 2;

    ast[astPointer] := length;
    astPointer := astPointer + 1;
    array_cpy(tokens, ast, valueStart, length, astPointer);

    astPointer := astPointer + length;
}

proc parse_type_expr(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    if (CURR_TOK = TOK_ARRAY) {
        NODE(NODE_ARR_TYPE_EXPR)
        RESERVE_NODE_LENGTH

        AST_W(0) // Reserve space for datatype initialized during name analysis

        EAT_TOKEN(TOK_ARRAY)
        EAT_TOKEN(TOK_LBRACK)

        AST_W(CURR_TOK_V) // Write size to AST
        EAT_TOKEN(TOK_INT)

        EAT_TOKEN(TOK_RBRACK)
        EAT_TOKEN(TOK_OF);

        parse_type_expr(ast, astPointer, tokens, tokenPointer);

        WRITE_NODE_LENGTH
    } else if (CURR_TOK = TOK_IDENT) {
        NODE(NODE_NAMED_TYPE_EXPR)
        RESERVE_NODE_LENGTH

        AST_W(0) // Reserve space for datatype initialized during name analysis

        parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
        EAT_TOKEN(TOK_IDENT)

        WRITE_NODE_LENGTH
    } else {
        exit(); // PARSE ERROR: expected type expression
    }
}

proc parse_type_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_TYPE_DECL)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_TYPE)

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_EQUAL)

    parse_type_expr(ast, astPointer, tokens, tokenPointer);

    EAT_SEMIC

    WRITE_NODE_LENGTH
}

proc parse_param_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_PARAM_DECL)
    RESERVE_NODE_LENGTH
    AST_W(0) // Reserve slot for datatype

    if (CURR_TOK = TOK_REF) {
        AST_W(1)
        EAT_TOKEN(TOK_REF)
    } else {
        AST_W(0)
    }

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_COLON)

    parse_type_expr(ast, astPointer, tokens, tokenPointer);

    WRITE_NODE_LENGTH
}

proc parse_param_decl_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_PARAM_DECL_LIST)
    RESERVE_NODE_LENGTH

    if (CURR_TOK # TOK_RPAREN) {
        parse_param_decl(ast, astPointer, tokens, tokenPointer);

        while (CURR_TOK = TOK_COMMA) {
            EAT_TOKEN(TOK_COMMA)

            parse_param_decl(ast, astPointer, tokens, tokenPointer);
        }
    }

    WRITE_NODE_LENGTH
}

proc parse_var_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_VAR_DECL)
    RESERVE_NODE_LENGTH 

    EAT_TOKEN(TOK_VAR)
    
    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_COLON)

    parse_type_expr(ast, astPointer, tokens, tokenPointer);

    EAT_SEMIC

    WRITE_NODE_LENGTH
}

proc parse_expr(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    parse_comparison(ast, astPointer, tokens, tokenPointer);
}

proc parse_comparison(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var hasOp: int;
    var nodeLengthPos: int;
    var nodeStart: int;
    var op: int;
    var i: int;

    leftStart := astPointer;
    parse_numeric(ast, astPointer, tokens, tokenPointer);
    leftEnd := astPointer;

    hasOp := 0;
    if (CURR_TOK = TOK_LT) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_LTE) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_GT) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_GTE) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_EQUAL) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_HASH) {
        hasOp := 1;
    }

    while (hasOp # 0) {
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 3] := ast[i];
            i := i - 1;
        }

        ast[leftStart] := NODE_BIN_EXPR;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        ast[leftStart + 2] := 0; // type slot
        nodeStart := leftStart + 2;

        astPointer := leftEnd + 3;

        op := CURR_TOK;
        AST_W(op);

        if (op = TOK_LT) {
            EAT_TOKEN(TOK_LT)
        } else if (op = TOK_LTE) {
            EAT_TOKEN(TOK_LTE)
        } else if (op = TOK_GT) {
            EAT_TOKEN(TOK_GT)
        } else if (op = TOK_GTE) {
            EAT_TOKEN(TOK_GTE)
        } else if (op = TOK_EQUAL) {
            EAT_TOKEN(TOK_EQUAL)
        } else {
            EAT_TOKEN(TOK_HASH)
        }

        parse_numeric(ast, astPointer, tokens, tokenPointer);

        ast[nodeLengthPos] := astPointer - nodeStart;

        leftEnd := astPointer;

        hasOp := 0;
        if (CURR_TOK = TOK_LT) {
            hasOp := 1;
        }
        if (CURR_TOK = TOK_LTE) {
            hasOp := 1;
        }
        if (CURR_TOK = TOK_GT) {
            hasOp := 1;
        }
        if (CURR_TOK = TOK_GTE) {
            hasOp := 1;
        }
        if (CURR_TOK = TOK_EQUAL) {
            hasOp := 1;
        }
        if (CURR_TOK = TOK_HASH) {
            hasOp := 1;
        }
    }
}

proc parse_numeric(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var hasOp: int;
    var nodeLengthPos: int;
    var nodeStart: int;
    var op: int;
    var i: int;

    leftStart := astPointer;
    parse_term(ast, astPointer, tokens, tokenPointer);
    leftEnd := astPointer;

    hasOp := 0;
    if (CURR_TOK = TOK_PLUS) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_MINUS) {
        hasOp := 1;
    }

    while (hasOp # 0) {
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 3] := ast[i];
            i := i - 1;
        }

        ast[leftStart] := NODE_BIN_EXPR;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        ast[leftStart + 2] := 0; // type slot (filled in semantic analysis)
        nodeStart := leftStart + 2;

        astPointer := leftEnd + 3;

        op := CURR_TOK;
        AST_W(op);

        if (op = TOK_PLUS) {
            EAT_TOKEN(TOK_PLUS)
        } else {
            EAT_TOKEN(TOK_MINUS)
        }

        parse_term(ast, astPointer, tokens, tokenPointer);

        ast[nodeLengthPos] := astPointer - nodeStart;

        leftEnd := astPointer;

        hasOp := 0;
        if (CURR_TOK = TOK_PLUS) {
            hasOp := 1;
        }
        if (CURR_TOK = TOK_MINUS) {
            hasOp := 1;
        }
    }
}

proc parse_term(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var hasOp: int;
    var nodeLengthPos: int;
    var nodeStart: int;
    var op: int;
    var i: int;

    leftStart := astPointer;
    parse_signed_factor(ast, astPointer, tokens, tokenPointer);
    leftEnd := astPointer;

    hasOp := 0;
    if (CURR_TOK = TOK_ASTERISK) {
        hasOp := 1;
    }
    if (CURR_TOK = TOK_SLASH) {
        hasOp := 1;
    }

    while (hasOp # 0) {
        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 3] := ast[i];
            i := i - 1;
        }

        ast[leftStart] := NODE_BIN_EXPR;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        ast[leftStart + 2] := 0; // type slot
        nodeStart := leftStart + 2;

        astPointer := leftEnd + 3;

        op := CURR_TOK;
        AST_W(op);

        if (op = TOK_ASTERISK) {
            EAT_TOKEN(TOK_ASTERISK)
        } else {
            EAT_TOKEN(TOK_SLASH)
        }

        parse_signed_factor(ast, astPointer, tokens, tokenPointer);

        ast[nodeLengthPos] := astPointer - nodeStart;

        leftEnd := astPointer;

        hasOp := 0;
        if (CURR_TOK = TOK_ASTERISK) {
            hasOp := 1;
        }
        if (CURR_TOK = TOK_SLASH) {
            hasOp := 1;
        }
    }
}

proc parse_signed_factor(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    if (CURR_TOK = TOK_MINUS) {
        NODE(NODE_UNA_EXPR)
        RESERVE_NODE_LENGTH
        AST_W(0) // Reserve space for data type initialized during semantic analysis

        AST_W(TOK_MINUS)
        EAT_TOKEN(TOK_MINUS)

        parse_factor(ast, astPointer, tokens, tokenPointer);

        WRITE_NODE_LENGTH
    } else {
        parse_factor(ast, astPointer, tokens, tokenPointer);
    }
}

proc parse_factor(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    if (CURR_TOK = TOK_IDENT) {
        NODE(NODE_VAR_EXPR)
        RESERVE_NODE_LENGTH
        AST_W(0) // Reserve space for data type initialized during semantic analysis

        parse_variable(ast, astPointer, tokens, tokenPointer);

        WRITE_NODE_LENGTH
    } else if (CURR_TOK = TOK_INT) {
        NODE(NODE_INT_LIT)
        RESERVE_NODE_LENGTH
        AST_W(0) // Reserve space for data type initialized during semantic analysis

        AST_W(CURR_TOK_V)
        EAT_TOKEN(TOK_INT)

        WRITE_NODE_LENGTH
    } else if (CURR_TOK = TOK_LPAREN) {
        EAT_TOKEN(TOK_LPAREN)
        parse_expr(ast, astPointer, tokens, tokenPointer);
        EAT_TOKEN(TOK_RPAREN)
    } else {
        exit(); // PARSE ERROR: expected expression factor
    }
}

proc parse_variable(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var leftStart: int;
    var leftEnd: int;
    var nodeStart: int;
    var nodeLengthPos: int;
    var i: int;

    leftStart := astPointer;

    NODE(NODE_NAMED_VAR)
    RESERVE_NODE_LENGTH
    AST_W(0) // Reserve space for datatype initialized during semantic analysis

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    WRITE_NODE_LENGTH

    leftEnd := astPointer;

    while (CURR_TOK = TOK_LBRACK) {
        EAT_TOKEN(TOK_LBRACK)

        i := leftEnd - 1;
        while (i >= leftStart) {
            ast[i + 3] := ast[i];
            i := i - 1;
        }

        ast[leftStart] := NODE_ARR_ACC;
        nodeLengthPos := leftStart + 1;
        ast[nodeLengthPos] := 0;
        ast[leftStart + 2] := 0; // Reserve space for datatype initialized during semantic analysis
        nodeStart := leftStart + 2;

        astPointer := leftEnd + 3;

        parse_expr(ast, astPointer, tokens, tokenPointer);

        EAT_TOKEN(TOK_RBRACK)

        ast[nodeLengthPos] := astPointer - nodeStart;

        leftEnd := astPointer;
    }
}

proc parse_assgn_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_ASSGN_STMT)
    RESERVE_NODE_LENGTH

    parse_variable(ast, astPointer, tokens, tokenPointer);

    EAT_TOKEN(TOK_ASSGN)

    parse_expr(ast, astPointer, tokens, tokenPointer);

    EAT_SEMIC

    WRITE_NODE_LENGTH 
}

proc parse_if_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_IF_STMT)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_IF)
    EAT_TOKEN(TOK_LPAREN)

    parse_expr(ast, astPointer, tokens, tokenPointer);

    EAT_TOKEN(TOK_RPAREN)

    parse_stmt(ast, astPointer, tokens, tokenPointer);

    if (CURR_TOK = TOK_ELSE) {
        EAT_TOKEN(TOK_ELSE)
        parse_stmt(ast, astPointer, tokens, tokenPointer);
    } else {
        NODE(NODE_EMPTY_STMT)
        RESERVE_NODE_LENGTH
    }

    WRITE_NODE_LENGTH 
}

proc parse_compound_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_COMP_STMT)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_LCURL);
    parse_stmt_list(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_RCURL);

    WRITE_NODE_LENGTH
}

proc parse_while_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_WHILE_STMT)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_WHILE)
    EAT_TOKEN(TOK_LPAREN)

    parse_expr(ast, astPointer, tokens, tokenPointer);

    EAT_TOKEN(TOK_RPAREN)

    parse_stmt(ast, astPointer, tokens, tokenPointer);

    WRITE_NODE_LENGTH 
}

proc parse_empty_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_EMPTY_STMT)
    RESERVE_NODE_LENGTH

    EAT_SEMIC

    WRITE_NODE_LENGTH
}

proc parse_arg_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_ARG_LIST)
    RESERVE_NODE_LENGTH

    if (CURR_TOK # TOK_RPAREN) {
        parse_expr(ast, astPointer, tokens, tokenPointer);

        while (CURR_TOK = TOK_COMMA) {
            EAT_TOKEN(TOK_COMMA)

            parse_expr(ast, astPointer, tokens, tokenPointer);
        }
    }

    WRITE_NODE_LENGTH
}

proc parse_call_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_CALL_STMT)
    RESERVE_NODE_LENGTH

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_LPAREN)
    parse_arg_list(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_RPAREN)

    EAT_SEMIC

    WRITE_NODE_LENGTH
}

proc parse_stmt(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    if (CURR_TOK = TOK_IDENT) {
        if (tokens[tokenPointer + tokens[tokenPointer + 1] + 2] = TOK_LPAREN) { // if next token is left paren
            parse_call_stmt(ast, astPointer, tokens, tokenPointer);
        } else {
            parse_assgn_stmt(ast, astPointer, tokens, tokenPointer);
        }
    } else if (CURR_TOK = TOK_IF) {
        parse_if_stmt(ast, astPointer, tokens, tokenPointer);
    } else if (CURR_TOK = TOK_LCURL) {
        parse_compound_stmt(ast, astPointer, tokens, tokenPointer);
    } else if (CURR_TOK = TOK_WHILE) {
        parse_while_stmt(ast, astPointer, tokens, tokenPointer);  
    } else if (CURR_TOK = TOK_SEMIC) {
        parse_empty_stmt(ast, astPointer, tokens, tokenPointer);
    }
}

proc parse_stmt_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;
    var continue: int;

    NODE(NODE_STMT_LIST)
    RESERVE_NODE_LENGTH

    continue := 0;
    if (CURR_TOK # TOK_RCURL) {
        if (CURR_TOK # TOK_EOF) {
            continue := 1;
        }
    }

    while (continue # 0) {
        parse_stmt(ast, astPointer, tokens, tokenPointer);

        continue := 0;
        if (CURR_TOK # TOK_RCURL) {
            if (CURR_TOK # TOK_EOF) {
                continue := 1;
            }
        }
    }

    WRITE_NODE_LENGTH
}

proc parse_var_decl_list(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_VAR_DECL_LIST)
    RESERVE_NODE_LENGTH

    while (CURR_TOK = TOK_VAR) {
        parse_var_decl(ast, astPointer, tokens, tokenPointer);
    }

    WRITE_NODE_LENGTH
}

proc parse_proc_decl(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    var nodeStart: int;
    var nodeLengthPos: int;

    NODE(NODE_PROC_DECL)
    RESERVE_NODE_LENGTH

    EAT_TOKEN(TOK_PROC)

    parse_cpy_ident(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_IDENT)

    EAT_TOKEN(TOK_LPAREN)
    parse_param_decl_list(ast, astPointer, tokens, tokenPointer);
    EAT_TOKEN(TOK_RPAREN)

    EAT_TOKEN(TOK_LCURL)

    parse_var_decl_list(ast, astPointer, tokens, tokenPointer);
    parse_stmt_list(ast, astPointer, tokens, tokenPointer);

    EAT_TOKEN(TOK_RCURL)

    WRITE_NODE_LENGTH
}

proc parse_global(ref ast: DataArray, ref astPointer: int, ref tokens: DataArray, ref tokenPointer: int) {
    if (CURR_TOK = TOK_TYPE) {
        parse_type_decl(ast, astPointer, tokens, tokenPointer);
    } else if (CURR_TOK = TOK_PROC) {
        parse_proc_decl(ast, astPointer, tokens, tokenPointer);
    } else {
        exit(); // PARSE ERROR: expected type declaration or procedure declaration
    }
}

proc parse_print_node_type(nodeType: int) {
    if (nodeType = NODE_ARG_LIST) {
        PC('A') PC('R') PC('G') PC('_') PC('L') PC('I') PC('S') PC('T')    
    } else if (nodeType = NODE_ARR_ACC) {
        PC('A') PC('R') PC('R') PC('_') PC('A') PC('C') PC('C');
    } else if (nodeType = NODE_ARR_TYPE_EXPR) {
        PC('A') PC('R') PC('R') PC('_') PC('T') PC('Y') PC('P') PC('E') PC('_') PC('E') PC('X') PC('P') PC('R')
    } else if (nodeType = NODE_ASSGN_STMT) {
        PC('A') PC('S') PC('S'); PC('G') PC('N') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_BIN_EXPR) {
        PC('B') PC('I') PC('N') PC('_') PC('E') PC('X') PC('P') PC('R')
    } else if (nodeType = NODE_CALL_STMT) {
        PC('C') PC('A') PC('L') PC('L') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_COMP_STMT) {
        PC('C') PC('O') PC('M') PC('P') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_EMPTY_STMT) {
        PC('E') PC('M') PC('P') PC('T') PC('Y') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_IF_STMT) {
        PC('I') PC('F') PC('_') PC('S') PC('T') PC('M') PC('T')
    } else if (nodeType = NODE_INT_LIT) {
        PC('I') PC('N') PC('T') PC('_') PC('L') PC('I') PC('T') 
    } else if (nodeType = NODE_NAMED_TYPE_EXPR) {
        PC('N') PC('A') PC('M'); PC('E') PC('D') PC('_') PC('T') PC('Y') PC('P') PC('E') PC('_') PC('E') PC('X') PC('P') PC('R')
    } else if (nodeType = NODE_NAMED_VAR) {
        PC('N') PC('A') PC('M'); PC('E') PC('D') PC('_') PC('V') PC('A') PC('R')
    } else if (nodeType = NODE_PARAM_DECL) {
        PC('P') PC('A') PC('R') PC('A') PC('M') PC('_') PC('D') PC('E') PC('C') PC('L')
    } else if (nodeType = NODE_PARAM_DECL_LIST) {
        PC('P') PC('A') PC('R') PC('A') PC('M') PC('_') PC('D') PC('E') PC('C') PC('L') PC('_') PC('L') PC('I') PC('S') PC('T')      
    } else if (nodeType = NODE_PROC_DECL) {
        PC('P') PC('R') PC('O') PC('C') PC('_') PC('D') PC('E') PC('C') PC('L')           
    } else if (nodeType = NODE_STMT_LIST) {
        PC('S') PC('T') PC('M') PC('T') PC('_') PC('L') PC('I') PC('S') PC('T')           
    } else if (nodeType = NODE_TYPE_DECL) {
        PC('T') PC('Y') PC('P') PC('E') PC('_') PC('D') PC('E') PC('C') PC('L')           
    } else if (nodeType = NODE_UNA_EXPR) {
        PC('U') PC('N') PC('A') PC('_') PC('E') PC('X') PC('P') PC('R')    
    } else if (nodeType = NODE_VAR_DECL) {
        PC('V') PC('A') PC('R') PC('_') PC('D') PC('E') PC('C') PC('L')        
    } else if (nodeType = NODE_VAR_DECL_LIST) {
        PC('V') PC('A') PC('R') PC('_') PC('D') PC('E') PC('C') PC('L') PC('_') PC('L') PC('I') PC('S') PC('T')         
    } else if (nodeType = NODE_VAR_EXPR) {
        PC('V') PC('A') PC('R') PC('_') PC('E') PC('X') PC('P') PC('R')    
    } else if (nodeType = NODE_WHILE_STMT) {
        PC('W') PC('H') PC('I') PC('L') PC('E') PC('_') PC('S') PC('T') PC('M') PC('T')       
    }
}

proc parse_print_list(ref ast: DataArray, ref astPointer: int, nodeType: int) {
    while (ast[astPointer] = nodeType) {
        parse_print_ast_rec(ast, astPointer);

        if (ast[astPointer] = nodeType) {
            printc(','); printc(' ');
        }
    }
}

proc parse_print_ast_rec(ref ast: DataArray, ref astPointer: int) {
    var nodeType: int;
    var nodeLength: int;
    var t: int;

    nodeType := ast[astPointer];
    astPointer := astPointer + 1;

    nodeLength := ast[astPointer];
    astPointer := astPointer + 1;

    printc('(');
    parse_print_node_type(nodeType);
    printc(' ');

    if (nodeType = NODE_TYPE_DECL) {
        PRINT_AST_IDENT

        printc(' ');

        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_NAMED_TYPE_EXPR) {
        astPointer := astPointer + 1; // Skip slot for datatype
        PRINT_AST_IDENT
    } else if (nodeType = NODE_ARR_TYPE_EXPR) {
        astPointer := astPointer + 1; // Skip slot for datatype
        printi(ast[astPointer]); // Size
        astPointer := astPointer + 1;

        printc(' ');

        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_PROC_DECL) {
        PRINT_AST_IDENT
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_PARAM_DECL_LIST) {
        parse_print_list(ast, astPointer, NODE_PARAM_DECL);
    } else if (nodeType = NODE_PARAM_DECL) {
        astPointer := astPointer + 1; // Skip slot for datatype
        printi(ast[astPointer]);
        astPointer := astPointer + 1;
        printc(' ');
        PRINT_AST_IDENT
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_VAR_DECL_LIST) {
        parse_print_list(ast, astPointer, NODE_VAR_DECL);  
    } else if (nodeType = NODE_VAR_DECL) {
        PRINT_AST_IDENT
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_STMT_LIST) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            parse_print_ast_rec(ast, astPointer);
            if (astPointer < t + nodeLength) {
                printc(',');
                printc(' ');
            }
        }
    } else if (nodeType = NODE_ASSGN_STMT) {
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_NAMED_VAR) {
        astPointer := astPointer + 1; // Skip slot for datatype
        PRINT_AST_IDENT
    } else if (nodeType = NODE_INT_LIT) {
        astPointer := astPointer + 1; // Skip slot for datatype
        printi(ast[astPointer]);
        astPointer := astPointer + 1;
    } else if (nodeType = NODE_BIN_EXPR) {
        astPointer := astPointer + 1; // Skip slot fot datatype
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        t := ast[astPointer]; // Operator
        if (t = TOK_EQUAL) {
            printc('=');
        } else if (t = TOK_HASH) {
            printc('#');
        } else if (t = TOK_LT) {
            printc('<');
        } else if (t = TOK_LTE) {
            printc('<'); printc('=');
        } else if (t = TOK_GT) {
            printc('>');
        } else if (t = TOK_GTE) {
            printc('>'); printc('=');
        } else if (t = TOK_PLUS) {
            printc('+');
        } else if (t = TOK_MINUS) {
            printc('-');
        } else if (t = TOK_ASTERISK) {
            printc('*');
        } else if (t = TOK_SLASH) {
            printc('/');
        }
        astPointer := astPointer + 1;
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_ARR_ACC) {
        astPointer := astPointer + 1; // Skip slot fot datatype
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_IF_STMT) {
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
    } else if (nodeType = NODE_COMP_STMT) {
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_WHILE_STMT) {
        parse_print_ast_rec(ast, astPointer);
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_CALL_STMT) {
        PRINT_AST_IDENT
        printc(' ');
        parse_print_ast_rec(ast, astPointer);      
    } else if (nodeType = NODE_ARG_LIST) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            parse_print_ast_rec(ast, astPointer);
            if (astPointer < t + nodeLength) {
                printc(',');
                printc(' ');
            }
        }
    } else if (nodeType = NODE_UNA_EXPR) {
        astPointer := astPointer + 1; // Skip slot fot datatype
        t := ast[astPointer]; // Operator 
        astPointer := astPointer + 1;
        if (t = TOK_MINUS) {
            printc('-');
        }
        printc(' ');
        parse_print_ast_rec(ast, astPointer);
    } else if (nodeType = NODE_VAR_EXPR) {
        astPointer := astPointer + 1; // Skip slot fot datatype
        parse_print_ast_rec(ast, astPointer);   
    }

    printc(')');
}

proc parse_print_ast(ref ast: DataArray) {
    var astPointer: int;

    astPointer := 0;

    parse_print_ast_rec(ast, astPointer);
    printc('\n');
}

proc parse(ref ast: DataArray, ref tokens: DataArray) {
    var nodeStart: int;
    var nodeLengthPos: int;
    var astPointer: int;
    var tokenPointer: int;

    astPointer := 0;
    tokenPointer := 0;

    NODE(NODE_STMT_LIST)
    RESERVE_NODE_LENGTH

    while (CURR_TOK # TOK_EOF) {
        parse_global(ast, astPointer, tokens, tokenPointer);
    }

    WRITE_NODE_LENGTH
}

proc symbol_table_lookup(
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref keyBuf: HashMapKeyBuffer, 
    keyLen: int, 
    ref found: int, 
    ref result: int
) {
    hashmap_get_str(CURRENT_TABLE, keyBuf, keyLen, found, result);

    if (found # 1) {
          hashmap_get_str(GLOBAL_TABLE, keyBuf, keyLen, found, result);  
    }
}

proc symbol_table_enter(ref table: HashMap, ref keyBuf: HashMapKeyBuffer, keyLen: int, value: int) {
    var found: int;
    var result: int;

    hashmap_get_str(table, keyBuf, keyLen, found, result);

    if (found # 0) {
        exit(); // ERROR: Symbol already declared
    }

    hashmap_put_str(table, keyBuf, keyLen, value);
}

proc name_analysis_type_decl(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    ref tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var identLength: int;
    var identStart: int;
    var typeIndex: int;
    var entryStart: int;
    var mapFound: int;
    var mapValue: int;

    identLength := ast[astPointer];
    astPointer := astPointer + 1;
    identStart := astPointer;
    astPointer := astPointer + identLength; // Skip ident data

    typeIndex := astPointer
        + 1  // Node type
        + 1; // Node length
        
    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

    entryStart := entryPointer;
    ENTRIES_W(SYM_TAB_ENTRY_TYPE)
    ENTRIES_W(SPL_TYPE_REF)
    ENTRIES_W(ast[typeIndex]);

    hashmap_cpy_key(ast, keyBuf, identStart, identLength);
    symbol_table_enter(GLOBAL_TABLE, keyBuf, identLength, entryStart);
}

proc name_analysis_named_type_expr(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    ref tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var typeSlot: int;
    var identLength: int;
    var mapFound: int;
    var mapValue: int;

    typeSlot := astPointer; // Save index of slot reserved for type
    astPointer := astPointer + 1; // Skip slot reserved for type

    identLength := ast[astPointer]; // Length of ident
    astPointer := astPointer + 1; // Skip length of ident
    hashmap_cpy_key(ast, keyBuf, astPointer, identLength);
    astPointer := astPointer + identLength; // Skip ident data
    symbol_table_lookup(symbolTables, tablePointer, keyBuf, identLength, mapFound, mapValue);

    if (mapFound # 1) {
        exit(); // ERROR: Undefined type
    }

    if (entries[mapValue] # SYM_TAB_ENTRY_TYPE) {
        exit(); // Error: Not a type
    }

    ast[typeSlot] := mapValue + 1; // Actual type follows entry type (SYM_TAB_ENTRY_TYPE, <type head>, <type data>)
} 

proc name_analysis_arr_type_expr(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    ref tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var typeSlot: int;
    var arrSize: int;
    var subTypeIndex: int;

    typeSlot := astPointer; // Save index of slot reserved for type
    astPointer := astPointer + 1; // Skip slot reserved for type

    arrSize := ast[astPointer];
    astPointer := astPointer + 1;

    subTypeIndex := astPointer
        + 1  // Node type
        + 1; // Node length

    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf); // Analyze base type

    ast[typeSlot] := entryPointer;
    ENTRIES_W(SPL_TYPE_ARRAY)
    ENTRIES_W(arrSize)
    ENTRIES_W(SPL_TYPE_REF)
    ENTRIES_W(ast[subTypeIndex]) // Index of sub type
}

proc name_analysis_var_decl(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    ref tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var nameStart: int;
    var nameLen: int;
    var typeIndex: int;
    var entryStart: int;

    nameLen := ast[astPointer];
    astPointer := astPointer + 1;
    nameStart := astPointer;
    astPointer := astPointer + nameLen;

    typeIndex := astPointer
        + 1  // Node type
        + 1; // Node length

    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

    entryStart := entryPointer;
    ENTRIES_W(SYM_TAB_ENTRY_VAR)
    ENTRIES_W(0) // is not reference
    ENTRIES_W(SPL_TYPE_REF)
    ENTRIES_W(ast[typeIndex]);
    ENTRIES_W(0) // Slot for variable position (register/stack offset)
    ENTRIES_W(0) // Slot for variable position (register/stack offset)

    hashmap_cpy_key(ast, keyBuf, nameStart, nameLen);
    symbol_table_enter(CURRENT_TABLE, keyBuf, nameLen, entryStart);
}

proc name_analysis_param_decl(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    ref tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var nameStart: int;
    var nameLen: int;
    var typeIndex: int;
    var entryStart: int;
    var isReference: int;
    var dataType: int;
    var resolvedType: int;

    dataType := astPointer;
    astPointer := astPointer + 1;

    isReference := ast[astPointer];
    astPointer := astPointer + 1;

    nameLen := ast[astPointer];
    astPointer := astPointer + 1;
    nameStart := astPointer;
    astPointer := astPointer + nameLen;

    typeIndex := astPointer
        + 1  // Node type
        + 1; // Node length


    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

    resolve_type_ref(ast[typeIndex], entries, resolvedType);

    if (entries[resolvedType] = SPL_TYPE_ARRAY) {
        if (isReference # 1) {
            exit(); // Must be a reference parameter
        }
    }

    ast[dataType] := ast[typeIndex];

    entryStart := entryPointer;
    ENTRIES_W(SYM_TAB_ENTRY_VAR)
    ENTRIES_W(isReference)
    ENTRIES_W(SPL_TYPE_REF)
    ENTRIES_W(ast[typeIndex]);
    ENTRIES_W(0) // Slot for variable position (register/stack offset)
    ENTRIES_W(0) // Slot for variable position (register/stack offset)

    hashmap_cpy_key(ast, keyBuf, nameStart, nameLen);
    symbol_table_enter(CURRENT_TABLE, keyBuf, nameLen, entryStart);
}

proc name_analysis_proc_decl(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    ref tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var procNameStart: int;
    var procNameLen: int;
    var paramTypes: DataArray;
    var paramTypesPointer: int;
    var typeIndex: int;
    var isReference: int;
    var paramCounter: int;
    var entryStart: int;

    tablePointer := tablePointer + 1;

    paramCounter := 0;
    paramTypesPointer := 1; // first element reserved for parameter count

    procNameLen := ast[astPointer];
    astPointer := astPointer + 1;
    procNameStart := astPointer;
    astPointer := astPointer + procNameLen;

    astPointer := astPointer + 1 + 1; // Skip param decl list header and length
    while (ast[astPointer] = NODE_PARAM_DECL) {
        astPointer := astPointer + 2; // Skip param decl header and length
        typeIndex := astPointer;
        isReference := ast[astPointer + 1];

        name_analysis_param_decl(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

        paramTypes[paramTypesPointer] := isReference;
        paramTypes[paramTypesPointer + 1] := 0; // Slot for parameter position (register/stack offset)
        paramTypes[paramTypesPointer + 2] := 0; // Slot for parameter position (register/stack offset)
        paramTypes[paramTypesPointer + 3] := SPL_TYPE_REF;
        paramTypes[paramTypesPointer + 4] := ast[typeIndex]; // Data type of parameter declaration
        paramTypesPointer := paramTypesPointer + 5;
        paramCounter := paramCounter + 1;
    }
    paramTypes[0] := paramCounter;

    astPointer := astPointer + 1 + 1; // Skip var decl list header and length
    while (ast[astPointer] = NODE_VAR_DECL) {
        astPointer := astPointer + 2; // Skip var decl header and length
        name_analysis_var_decl(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    }

    entryStart := entryPointer;
    ENTRIES_W(SYM_TAB_ENTRY_PROC)
    ENTRIES_W(tablePointer)

    array_cpy(paramTypes, entries, 0, paramTypesPointer, entryPointer); // Copy parameter types
    entryPointer := entryPointer + paramTypesPointer;

    ENTRIES_W(0) // Local Variable Area Size
    ENTRIES_W(0) // Argument Area Size
    ENTRIES_W(0) // Outgoing Area Size

    hashmap_cpy_key(ast, keyBuf, procNameStart, procNameLen);
    symbol_table_enter(GLOBAL_TABLE, keyBuf, procNameLen, entryStart);

    SKIP_NODE // Skip statements
}

proc name_analysis_check_main(ref table: HashMap, ref entries: DataArray) {
    var keyBuf: HashMapKeyBuffer;
    var found: int;
    var value: int;
    var parametersCount: int;

    keyBuf[0] := 'm';
    keyBuf[1] := 'a';
    keyBuf[2] := 'i';
    keyBuf[3] := 'n';

    hashmap_get_str(table, keyBuf, 4, found, value);

    if (found # 1) {
        exit(); // Error: Main procedure missing
    }

    if (entries[value] # SYM_TAB_ENTRY_PROC) {
        exit(); // Error: Main is not a procedure
    }

    if (entries[value + 2] # 0) {
        exit(); // Error: Main must not have parameters
    }
}

proc name_analysis_rec(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    ref tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var nodeType: int;
    var nodeLength: int;
    var t: int;
   
    nodeType := ast[astPointer];
    astPointer := astPointer + 1;

    nodeLength := ast[astPointer];
    astPointer := astPointer + 1;

    if (nodeType = NODE_TYPE_DECL) {
        name_analysis_type_decl(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_NAMED_TYPE_EXPR) {
        name_analysis_named_type_expr(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_ARR_TYPE_EXPR) {
        name_analysis_arr_type_expr(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_PROC_DECL) {
        name_analysis_proc_decl(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_STMT_LIST) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            name_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
        }
    } else {
        exit(); // INTERNAL ERROR: Unexpected type
    }
}

proc name_analysis(ref ast: DataArray, ref symbolTables: SymbolTables, ref symbolTableEntries: DataArray, ref entryPointer: int) {
    var astPointer: int;
    var keyBuf: HashMapKeyBuffer;
    var tablePointer: int;

    astPointer := 0;
    tablePointer := 0;

    name_analysis_rec(ast, astPointer, symbolTables, tablePointer, symbolTableEntries, entryPointer, keyBuf);

    name_analysis_check_main(GLOBAL_TABLE, symbolTableEntries);
}

// TODO: Parameter positions, drawing procedures
proc init_global_table(ref table: HashMap, headless: int, ref entries: DataArray, ref entryPointer: int) {
    var keyBuf: HashMapKeyBuffer;

    // bool - ahs to be written to entries table for semantic analysis
    ENTRIES_W(SPL_TYPE_BOOL)

    // int
    keyBuf[0] := 'i';
    keyBuf[1] := 'n';
    keyBuf[2] := 't';

    hashmap_put_str(table, keyBuf, 3, entryPointer);

    ENTRIES_W(SYM_TAB_ENTRY_TYPE)
    ENTRIES_W(SPL_TYPE_INT)

    // printi(i: int)
    keyBuf[0] := 'p';
    keyBuf[1] := 'r';
    keyBuf[2] := 'i';
    keyBuf[3] := 'n';
    keyBuf[4] := 't';
    keyBuf[5] := 'i';

    hashmap_put_str(table, keyBuf, 6, entryPointer);  

    ENTRIES_W(SYM_TAB_ENTRY_PROC)
    ENTRIES_W(-1) // Symbol table of procedure (-1 for builtin)
    ENTRIES_W(1) // One parameter
    ENTRIES_W(0) // Parameter is not reference
    ENTRIES_W(REG_RDI) // Position of parameter 1
    ENTRIES_W(0) // Offset is zero for parameters passed by register
    ENTRIES_W(SPL_TYPE_REF)
    ENTRIES_W(SPL_TYPE_INT_INDEX)
    ENTRIES_W(0) // Local Variable Area Size
    ENTRIES_W(0) // Argument Area Size
    ENTRIES_W(0) // Outgoing Area Size

    // printc(i: int)
    keyBuf[0] := 'p';
    keyBuf[1] := 'r';
    keyBuf[2] := 'i';
    keyBuf[3] := 'n';
    keyBuf[4] := 't';
    keyBuf[5] := 'c';

    hashmap_put_str(table, keyBuf, 6, entryPointer);  

    ENTRIES_W(SYM_TAB_ENTRY_PROC)
    ENTRIES_W(-1) // Symbol table of procedure (-1 for builtin)
    ENTRIES_W(1) // One parameter
    ENTRIES_W(0) // Parameter is not reference
    ENTRIES_W(REG_RDI) // Position of parameter 1
    ENTRIES_W(0) // Offset is zero for parameters passed by register
    ENTRIES_W(SPL_TYPE_REF)
    ENTRIES_W(SPL_TYPE_INT_INDEX)
    ENTRIES_W(0) // Local Variable Area Size
    ENTRIES_W(0) // Argument Area Size
    ENTRIES_W(0) // Outgoing Area Size

    // readi(ref i: int)
    keyBuf[0] := 'r';
    keyBuf[1] := 'e';
    keyBuf[2] := 'a';
    keyBuf[3] := 'd';
    keyBuf[4] := 'i';

    hashmap_put_str(table, keyBuf, 5, entryPointer);  

    ENTRIES_W(SYM_TAB_ENTRY_PROC)
    ENTRIES_W(-1) // Symbol table of procedure (-1 for builtin)
    ENTRIES_W(1) // One parameter
    ENTRIES_W(1) // Parameter IS reference
    ENTRIES_W(REG_RDI) // Position of parameter 1
    ENTRIES_W(0) // Offset is zero for parameters passed by register
    ENTRIES_W(SPL_TYPE_REF)
    ENTRIES_W(SPL_TYPE_INT_INDEX)
    ENTRIES_W(0) // Local Variable Area Size
    ENTRIES_W(0) // Argument Area Size
    ENTRIES_W(0) // Outgoing Area Size

    // readc(ref i: int)
    keyBuf[0] := 'r';
    keyBuf[1] := 'e';
    keyBuf[2] := 'a';
    keyBuf[3] := 'd';
    keyBuf[4] := 'c';

    hashmap_put_str(table, keyBuf, 5, entryPointer);  

    ENTRIES_W(SYM_TAB_ENTRY_PROC)
    ENTRIES_W(-1) // Symbol table of procedure (-1 for builtin)
    ENTRIES_W(1) // One parameter
    ENTRIES_W(1) // Parameter IS reference
    ENTRIES_W(REG_RDI) // Position of parameter 1
    ENTRIES_W(0) // Offset is zero for parameters passed by register
    ENTRIES_W(SPL_TYPE_REF)
    ENTRIES_W(SPL_TYPE_INT_INDEX)
    ENTRIES_W(0) // Local Variable Area Size
    ENTRIES_W(0) // Argument Area Size
    ENTRIES_W(0) // Outgoing Area Size

    // exit()
    keyBuf[0] := 'e';
    keyBuf[1] := 'x';
    keyBuf[2] := 'i';
    keyBuf[3] := 't';

    hashmap_put_str(table, keyBuf, 4, entryPointer);  

    ENTRIES_W(SYM_TAB_ENTRY_PROC)
    ENTRIES_W(-1) // Symbol table of procedure (-1 for builtin)
    ENTRIES_W(0) // No parameters
    ENTRIES_W(0) // Local Variable Area Size
    ENTRIES_W(0) // Argument Area Size
    ENTRIES_W(0) // Outgoing Area Size

    // time(ref i: int)
    keyBuf[0] := 't';
    keyBuf[1] := 'i';
    keyBuf[2] := 'm';
    keyBuf[3] := 'e';

    hashmap_put_str(table, keyBuf, 4, entryPointer);  

    ENTRIES_W(SYM_TAB_ENTRY_PROC)
    ENTRIES_W(-1) // Symbol table of procedure (-1 for builtin)
    ENTRIES_W(1) // One parameter
    ENTRIES_W(1) // Parameter IS reference
    ENTRIES_W(REG_RDI) // Position of parameter 1
    ENTRIES_W(0) // Offset is zero for parameters passed by register
    ENTRIES_W(SPL_TYPE_REF)
    ENTRIES_W(SPL_TYPE_INT_INDEX)
    ENTRIES_W(0) // Local Variable Area Size
    ENTRIES_W(0) // Argument Area Size
    ENTRIES_W(0) // Outgoing Area Size
}

proc print_type(ref entries: DataArray, ref entryPointer: int) {
    var head: int;
    var t: int;

    head := entries[entryPointer];

    entryPointer := entryPointer + 1;

    if (head = SPL_TYPE_INT) {
        printc('i'); printc('n'); printc('t');
    } else if (head = SPL_TYPE_BOOL) {
        printc('b'); printc('o'); printc('o'); printc('l');    
    } else if (head = SPL_TYPE_ARRAY) {
        printc('a'); printc('r'); printc('r'); printc('a'); printc('y');
        printc('[');
        printi(entries[entryPointer]);
        entryPointer := entryPointer + 1;
        printc(']');
        printc(' '); printc('o'); printc('f'); printc(' ');
        print_type(entries, entryPointer);   
    } else if (head = SPL_TYPE_REF) {
        t := entryPointer;
        entryPointer := entries[entryPointer];
        print_type(entries, entryPointer);   
        entryPointer := t + 1;
    } else {
        exit(); // ERROR: Illegal type head
    }
}

proc print_procedure_type(ref entries: DataArray, ref entryPointer: int) {
    var i: int;
    var parameterCount: int;
    var isReference: int;

    parameterCount := entries[entryPointer];
    entryPointer := entryPointer + 1;
    i := 0;
    while (i < parameterCount) {
        isReference := entries[entryPointer];
        entryPointer := entryPointer + 1;
        entryPointer := entryPointer + 2; // Skip parameter location (register/stack offset)

        if (isReference # 0) {
            printc('r'); printc('e'); printc('f'); printc(' ');
        }

        print_type(entries, entryPointer);

        i := i + 1;

        if (i < parameterCount) {
            printc(',');
            printc(' ');
        }
    }
}

proc print_table(ref symbolTable: HashMap, ref entries: DataArray) {
    var i: int;
    var start: int;
    var len: int;
    var j: int;
    var c: int;
    var valueFound: int;
    var entryPointer: int;
    var keyBuf: HashMapKeyBuffer;
    var isReference: int;

    i := 0;
    while (i < HASHMAP_SIZE) {
        if (HASH_USED(symbolTable)[i] # 0) {
            start := HASH_KEY_START(symbolTable)[i];
            len := HASH_KEY_LEN(symbolTable)[i];

            j := 0;
            while (j < len) {
                c := HASH_POOL(symbolTable)[start + j + 1];
                printc(c);
                keyBuf[j] := c;

                j := j + 1;
            }

            printc(' '); printc('-'); printc('-'); printc('>'); printc(' ');

            hashmap_get_str(symbolTable, keyBuf, j, valueFound, entryPointer);

            if (entries[entryPointer] = SYM_TAB_ENTRY_TYPE) {
                entryPointer := entryPointer + 1;
                printc('t'); printc('y'); printc('p'); printc('e'); printc(':'); printc(' ');
                print_type(entries, entryPointer);
            } else if (entries[entryPointer] = SYM_TAB_ENTRY_PROC) {
                entryPointer := entryPointer + 1;
                entryPointer := entryPointer + 1; // Skip symbol table
                printc('p'); printc('r'); printc('o'); printc('c'); printc(':'); printc(' '); printc('(');
                print_procedure_type(entries, entryPointer);
                printc(')');
                entryPointer := entryPointer + 3; // Skip stack layout (local variable area size, argument area size, outgoing area size)
            } else if (entries[entryPointer] = SYM_TAB_ENTRY_VAR) {
                entryPointer := entryPointer + 1;
                isReference := entries[entryPointer];
                entryPointer := entryPointer + 1;
                printc('v'); printc('a'); printc('r'); printc(':'); printc(' ');
                if (isReference # 0) {
                    printc('r'); printc('e'); printc('f'); printc(' ');
                }
                print_type(entries, entryPointer);
                entryPointer := entryPointer + 2; // Skip variable position (register/stack offset)
            } else {
                exit(); // INTERNAL ERROR: Unexpected type
            }

            printc('\n');
        }
        i := i + 1;
    }
}

proc print_tables(ref symbolTables: SymbolTables, ref entries: DataArray, count: int) {
    var i: int;

    i := 0;

    while (i < count) {
        printc('t'); printc('a'); printc('b'); printc('l'); printc('e'); printc(' '); printi(i);
        printc('\n');
        print_table(symbolTables[i], entries);
        printc('\n');

        i := i + 1;
    }
}

proc init_table_maps(ref symbolTables: SymbolTables) {
    var i: int;

    i := 0;
    while (i < MAX_SYMBOL_TABLES) {
        hashmap_init(symbolTables[i]);

        i := i + 1;
    }
}

proc semantic_analysis_proc_decl(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var procNameStart: int;
    var procNameLen: int;
    var procEntryIndex: int;
    var procEntryFound: int;
    var localTablePointer: int;

    procNameLen := ast[astPointer];
    astPointer := astPointer + 1;
    procNameStart := astPointer;
    astPointer := astPointer + procNameLen;

    hashmap_cpy_key(ast, keyBuf, procNameStart, procNameLen);
    symbol_table_lookup(symbolTables, 0, keyBuf, procNameLen, procEntryFound, procEntryIndex);

    localTablePointer := entries[procEntryIndex + 1]; // Type at procEntryIndex is ENTRY_PROC, then follows table pointer

    SKIP_NODE // Skip param decl list
    SKIP_NODE // Skip var decl 
    
    semantic_analysis_rec(ast, astPointer, symbolTables, localTablePointer, entries, entryPointer, keyBuf);
}

proc resolve_type_ref(typeIndex: int, ref entries: DataArray, ref r: int) {
    if (entries[typeIndex] = SPL_TYPE_REF) {
        resolve_type_ref(entries[typeIndex + 1], entries, r);
    } else {
        r := typeIndex;
    }
}

proc compare_types(left: int, right: int, ref entries: DataArray) {
    var leftResolved: int;
    var rightResolved: int;

    resolve_type_ref(left, entries, leftResolved);
    resolve_type_ref(right, entries, rightResolved);

    if (leftResolved # rightResolved) {
        exit(); // SEMANTIC ERROR: Type mismatch
    }
}

proc semantic_analysis_assgn_stmt(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var targetTypeIndex: int;
    var valueTypeIndex: int;

    targetTypeIndex := astPointer + 1 + 1; 
    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf); // Assignment target

    valueTypeIndex := astPointer + 1 + 1;
    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf); // Value
    
    compare_types(ast[targetTypeIndex], ast[valueTypeIndex], entries); 
    compare_types(ast[valueTypeIndex], SPL_TYPE_INT_INDEX, entries);
}

proc semantic_analysis_una_expr(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var thisTypeIndex: int;
    var operator: int;
    var operandType: int;

    thisTypeIndex := astPointer;
    astPointer := astPointer + 1;

    operator := ast[astPointer];
    astPointer := astPointer + 1;

    operandType := astPointer + 1 + 1;

    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

    compare_types(ast[operandType], SPL_TYPE_INT_INDEX, entries);

    ast[thisTypeIndex] := ast[operandType];
}

proc semantic_analysis_named_var(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var nameStart: int;
    var nameLen: int;
    var entryFound: int;
    var entryIndex: int;
    var typeIndex: int;

    typeIndex := astPointer;
    astPointer := astPointer + 1;

    nameLen := ast[astPointer];
    astPointer := astPointer + 1;
    nameStart := astPointer;
    astPointer := astPointer + nameLen;

    hashmap_cpy_key(ast, keyBuf, nameStart, nameLen);
    symbol_table_lookup(symbolTables, tablePointer, keyBuf, nameLen, entryFound, entryIndex);

    if (entryFound # 1) {
        exit(); // SEMANTIC ERROR: Variable undefined
    }

    if (entries[entryIndex] # SYM_TAB_ENTRY_VAR) {
        exit(); // SEMANTIC ERROR: Not a variable
    }

    ast[typeIndex] := entryIndex + 2; // +0 is SYM_TAB_ENTRY_VAR, +1 is whether reference, +2 is actual type
}

proc semantic_analysis_int_lit(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    ast[astPointer] := SPL_TYPE_INT_INDEX;
    astPointer := astPointer + 1 + 1; // Skip type slot and int value
}

proc semantic_analysis_arr_acc(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var thisTypeIndex: int;
    var arrayTypeIndex: int;
    var indexTypeIndex: int;
    var resolvedArrayTypeIndex: int;

    thisTypeIndex := astPointer;
    astPointer := astPointer + 1;
    
    arrayTypeIndex := astPointer + 1 + 1;
    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

    resolve_type_ref(ast[arrayTypeIndex], entries, resolvedArrayTypeIndex);

    if (entries[resolvedArrayTypeIndex] # SPL_TYPE_ARRAY) {
        exit(); // SEMANTIC ERROR: Indexing non-array
    }

    ast[thisTypeIndex] := resolvedArrayTypeIndex + 2; // Base type is at +2, +1 is array size

    indexTypeIndex := astPointer + 1 + 1;
    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    
    compare_types(ast[indexTypeIndex], SPL_TYPE_INT_INDEX, entries);
}

proc semantic_analysis_bin_expr(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var thisTypeIndex: int;
    var leftTypeIndex: int;
    var rightTypeIndex: int;
    var operator: int;

    thisTypeIndex := astPointer;
    astPointer := astPointer + 1;
    
    leftTypeIndex := astPointer + 1 + 1;
    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    
    operator := ast[astPointer];
    astPointer := astPointer + 1;

    rightTypeIndex := astPointer + 1 + 1;
    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

    compare_types(ast[leftTypeIndex], SPL_TYPE_INT_INDEX, entries);
    compare_types(ast[rightTypeIndex], SPL_TYPE_INT_INDEX, entries);

    if (operator = TOK_PLUS) {
        ast[thisTypeIndex] := SPL_TYPE_INT_INDEX;
    } else if (operator = TOK_MINUS) {
        ast[thisTypeIndex] := SPL_TYPE_INT_INDEX;
    } else if (operator = TOK_ASTERISK) {
        ast[thisTypeIndex] := SPL_TYPE_INT_INDEX;
    } else if (operator = TOK_SLASH) {
        ast[thisTypeIndex] := SPL_TYPE_INT_INDEX;
    } else if (operator = TOK_LT) {
        ast[thisTypeIndex] := SPL_TYPE_BOOL_INDEX;
    } else if (operator = TOK_LTE) {
        ast[thisTypeIndex] := SPL_TYPE_BOOL_INDEX;
    } else if (operator = TOK_GT) {
        ast[thisTypeIndex] := SPL_TYPE_BOOL_INDEX;
    } else if (operator = TOK_GTE) {
        ast[thisTypeIndex] := SPL_TYPE_BOOL_INDEX;
    } else if (operator = TOK_EQUAL) {
        ast[thisTypeIndex] := SPL_TYPE_BOOL_INDEX;
    } else if (operator = TOK_HASH) {
        ast[thisTypeIndex] := SPL_TYPE_BOOL_INDEX;
    } else {
        exit(); // INTERNAL ERROR: Unknown operator
    }
}

proc semantic_analysis_if_stmt(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var conditionTypeIndex: int;

    conditionTypeIndex := astPointer + 1 + 1;

    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

    compare_types(ast[conditionTypeIndex], SPL_TYPE_BOOL_INDEX, entries);

    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf); // Consequence
    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf); // Alternative
}

proc semantic_analysis_while_stmt(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var conditionTypeIndex: int;

    conditionTypeIndex := astPointer + 1 + 1;

    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

    compare_types(ast[conditionTypeIndex], SPL_TYPE_BOOL_INDEX, entries);

    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf); // Body
}

proc semantic_analysis_var_expr(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var thisTypeIndex: int;
    var childTypeIndex: int;

    thisTypeIndex := astPointer;
    astPointer := astPointer + 1; // Skip type slot

    childTypeIndex := astPointer + 1 + 1;
    semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);

    ast[thisTypeIndex] := ast[childTypeIndex];
}

proc semantic_analysis_call_stmt(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var nameStart: int;
    var nameLen: int;
    var entryFound: int;
    var entryIndex: int;
    var argsCounter: int;
    var argsEndIndex: int;
    var paramCount: int;
    var paramListStart: int;
    var currParamIndex: int;
    var currArgTypeIndex: int;
    var argsCountingIndex: int;

    nameLen := ast[astPointer];
    astPointer := astPointer + 1;
    nameStart := astPointer;
    astPointer := astPointer + nameLen;

    hashmap_cpy_key(ast, keyBuf, nameStart, nameLen);
    symbol_table_lookup(symbolTables, tablePointer, keyBuf, nameLen, entryFound, entryIndex);

    if (entries[entryIndex] # SYM_TAB_ENTRY_PROC) {
        exit(); // SEMANTIC ERROR: CaLL of non-procedure
    }

    paramListStart := entryIndex + 3;
    paramCount := entries[entryIndex + 2]; // +1 is local table, +2 is param count

    astPointer := astPointer + 1; // Skip argument list node head
    argsEndIndex := astPointer + ast[astPointer];
    astPointer := astPointer + 1; // Skip argument list node length

    argsCounter := 0;
    argsCountingIndex := astPointer;
    while (argsCountingIndex < argsEndIndex) {
        argsCountingIndex := argsCountingIndex + 1 + 1 + ast[argsCountingIndex + 1];
        argsCounter := argsCounter + 1;
    }

    if (argsCounter # paramCount) {
        exit(); // Wrong number of arguments to function
    }

    argsCounter := 0;
    while (astPointer < argsEndIndex) {
        currParamIndex := paramListStart + argsCounter * 5;

        if (entries[currParamIndex] # 0) { // If current param type is reference
            if (ast[astPointer] # NODE_VAR_EXPR) {
                exit(); // SEMANTIC ERROR: Argument must be a variable
            }
        }

        currArgTypeIndex := astPointer + 1 + 1;

        semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
        compare_types(ast[currArgTypeIndex], currParamIndex + 3, entries);

        argsCounter := argsCounter + 1;
    }
}

proc semantic_analysis_rec(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref entryPointer: int,
    ref keyBuf: HashMapKeyBuffer
) {
    var nodeType: int;
    var nodeLength: int;
    var t: int;
   
    nodeType := ast[astPointer];
    astPointer := astPointer + 1;

    nodeLength := ast[astPointer];
    astPointer := astPointer + 1;

    if (nodeType = NODE_STMT_LIST) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
        }
    } else if (nodeType = NODE_PROC_DECL) {
        semantic_analysis_proc_decl(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_ASSGN_STMT) {
        semantic_analysis_assgn_stmt(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_UNA_EXPR) {
        semantic_analysis_una_expr(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_NAMED_VAR) {
        semantic_analysis_named_var(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_INT_LIT) {
        semantic_analysis_int_lit(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);      
    } else if (nodeType = NODE_ARR_ACC) {
        semantic_analysis_arr_acc(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);   
    } else if (nodeType = NODE_BIN_EXPR) {
         semantic_analysis_bin_expr(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);          
    } else if (nodeType = NODE_IF_STMT) {
        semantic_analysis_if_stmt(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);        
    } else if (nodeType = NODE_WHILE_STMT) {
        semantic_analysis_while_stmt(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_VAR_EXPR) {
        semantic_analysis_var_expr(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_CALL_STMT) {
        semantic_analysis_call_stmt(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_COMP_STMT) {
        semantic_analysis_rec(ast, astPointer, symbolTables, tablePointer, entries, entryPointer, keyBuf);
    } else if (nodeType = NODE_EMPTY_STMT) {
    } else {
        astPointer := astPointer + nodeLength; // Skip unhandled nodes
    }
}

proc semantic_analysis(ref ast: DataArray, ref symbolTables: SymbolTables, ref symbolTableEntries: DataArray, ref entryPointer: int) {
    var astPointer: int;
    var keyBuf: HashMapKeyBuffer;

    astPointer := 0;

    semantic_analysis_rec(ast, astPointer, symbolTables, 0, symbolTableEntries, entryPointer, keyBuf);
}

proc calc_type_byte_size(typeIndex: int, ref entries: DataArray, ref r: int) {
    var resolvedType: int;
    var arrSubTypeSize: int;
    var arrLen: int;

    resolve_type_ref(typeIndex, entries, resolvedType);

    if (entries[resolvedType] = SPL_TYPE_INT) {
        r := r + WORD_SIZE;
    } else if (entries[resolvedType] = SPL_TYPE_ARRAY) {
        arrLen := entries[resolvedType + 1];
        arrSubTypeSize := 0;
        calc_type_byte_size(resolvedType + 2, entries, arrSubTypeSize);
        r := r + arrSubTypeSize * arrLen;
    } else {
        exit(); // INTERNAL ERROR: Unknwon type
    }
}

proc outgoing_area(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref keyBuf: HashMapKeyBuffer,
    ref r: int
) {
    var nodeType: int;
    var nodeLength: int;
    var t: int;
    var argumentsSize: int;
    var paramCount: int;
    var procNameLen: int;
    var procNameStart: int;
    var procEntryFound: int;
    var procEntryIndex: int;
   
    nodeType := ast[astPointer];
    astPointer := astPointer + 1;

    nodeLength := ast[astPointer];
    astPointer := astPointer + 1;

    if (nodeType = NODE_CALL_STMT) {
        procNameLen := ast[astPointer];
        astPointer := astPointer + 1;
        procNameStart := astPointer;
        astPointer := astPointer + procNameLen;

        hashmap_cpy_key(ast, keyBuf, procNameStart, procNameLen);
        symbol_table_lookup(symbolTables, 0, keyBuf, procNameLen, procEntryFound, procEntryIndex);

        SKIP_NODE // Skip arg list

        argumentsSize := 0;
        paramCount := entries[procEntryIndex + 2];

        // Note: Calculating actual byte size is not necessary since arrays can only be passed by reference.
        // Therefore, each parameter must have a byte size of exactly WORD_SIZE since both ints and references are of size WORD_SIZE.
        argumentsSize := paramCount * WORD_SIZE - 6 * WORD_SIZE;

        if (argumentsSize > r) {
            r := argumentsSize;
        }
    } else if (nodeType = NODE_COMP_STMT) {
        outgoing_area(ast, astPointer, symbolTables, tablePointer, entries, keyBuf, r); // body  
    } else if (nodeType = NODE_IF_STMT) {
        SKIP_NODE // Skip condition
        outgoing_area(ast, astPointer, symbolTables, tablePointer, entries, keyBuf, r); // then
        outgoing_area(ast, astPointer, symbolTables, tablePointer, entries, keyBuf, r); // else
    } else if (nodeType = NODE_WHILE_STMT) {
        SKIP_NODE // Skip Condition
        outgoing_area(ast, astPointer, symbolTables, tablePointer, entries, keyBuf, r);
    } else if (nodeType = NODE_STMT_LIST) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            outgoing_area(ast, astPointer, symbolTables, tablePointer, entries, keyBuf, r);
        }
    } else {
        astPointer := astPointer + nodeLength; // Skip unhandled nodes
    }
}

proc var_alloc_param_decl_list(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref keyBuf: HashMapKeyBuffer,
    procEntryIndex: int
) {
    var paramCount: int;
    var i: int;
    var currParamIndex: int;
    var varEntryIndex: int;
    var varEntryFound: int;
    var varNameStart: int;
    var varNameLen: int;

    paramCount := entries[procEntryIndex + 2];

    astPointer := astPointer + 1 + 1; // Skip param decl list head and length

    i := 0;
    currParamIndex := 0;
    while (i < paramCount) {
        astPointer := astPointer + 4; // Skip head, length, datatype, isReference

        varNameLen := ast[astPointer];
        astPointer := astPointer + 1;
        varNameStart := astPointer;
        astPointer := astPointer + varNameLen;

        hashmap_cpy_key(ast, keyBuf, varNameStart, varNameLen);
        symbol_table_lookup(symbolTables, tablePointer, keyBuf, varNameLen, varEntryFound, varEntryIndex);

        // Note: Calculating actual byte size is not necessary since arrays can only be passed by reference.
        // Therefore, each parameter must have a byte size of exactly WORD_SIZE since both ints and references are of size WORD_SIZE.
        if (i < 6) { // First six arguments are passed by register
            CURR_PARAM_POSITION := i; // Maps to defined registers

            VAR_ENTRY_POSITION := REG_RBP;
            VAR_ENTRY_OFFSET := -STACK_LAYOUT_LOCAL_VAR_AREA_SIZE - WORD_SIZE;

            STACK_LAYOUT_LOCAL_VAR_AREA_SIZE := STACK_LAYOUT_LOCAL_VAR_AREA_SIZE + WORD_SIZE;
        } else {
            CURR_PARAM_POSITION := REG_RSP;
            CURR_PARAM_OFFSET := STACK_LAYOUT_ARG_AREA_SIZE;

            VAR_ENTRY_POSITION := REG_RBP;
            VAR_ENTRY_OFFSET := STACK_LAYOUT_ARG_AREA_SIZE + 16; // old frame pointer (8) + return address (8)

            STACK_LAYOUT_ARG_AREA_SIZE := STACK_LAYOUT_ARG_AREA_SIZE + WORD_SIZE;
        }

        SKIP_NODE // Skip type expression

        currParamIndex := currParamIndex + 5; // Skip isReference, position, ref, typeref
        i := i + 1;
    }
}

proc var_alloc_var_decl_list(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref keyBuf: HashMapKeyBuffer,
    procEntryIndex: int,
    paramCount: int
) {
    var varNameLen: int;
    var varNameStart: int;
    var varEntryFound: int;
    var varEntryIndex: int;
    var typeSize: int;

    astPointer := astPointer + 2; // Skip var decl list head and length

    while (ast[astPointer] = NODE_VAR_DECL) {
        astPointer := astPointer + 2; // Skip var decl head and length

        varNameLen := ast[astPointer];
        astPointer := astPointer + 1;
        varNameStart := astPointer;
        astPointer := astPointer + varNameLen;

        SKIP_NODE // Skip type expression

        hashmap_cpy_key(ast, keyBuf, varNameStart, varNameLen);
        symbol_table_lookup(symbolTables, tablePointer, keyBuf, varNameLen, varEntryFound, varEntryIndex);

        typeSize := 0;
        calc_type_byte_size(VAR_ENTRY_TYPE_INDEX, entries, typeSize);

        VAR_ENTRY_POSITION := REG_RBP;
        VAR_ENTRY_OFFSET := -STACK_LAYOUT_LOCAL_VAR_AREA_SIZE - typeSize;
        STACK_LAYOUT_LOCAL_VAR_AREA_SIZE := STACK_LAYOUT_LOCAL_VAR_AREA_SIZE + typeSize;
    }
}

proc var_alloc_proc_decl(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref keyBuf: HashMapKeyBuffer
) {
    var procNameStart: int;
    var procNameLen: int;
    var procEntryIndex: int;
    var procEntryFound: int;
    var localTablePointer: int;
    var outgoingAreaSize: int;
    var paramCount: int;

    procNameLen := ast[astPointer];
    astPointer := astPointer + 1;
    procNameStart := astPointer;
    astPointer := astPointer + procNameLen;

    hashmap_cpy_key(ast, keyBuf, procNameStart, procNameLen);
    symbol_table_lookup(symbolTables, 0, keyBuf, procNameLen, procEntryFound, procEntryIndex);

    paramCount := entries[procEntryIndex + 2];

    localTablePointer := entries[procEntryIndex + 1];

    var_alloc_param_decl_list(ast, astPointer, symbolTables, localTablePointer, entries, keyBuf, procEntryIndex);
    
    var_alloc_var_decl_list(ast, astPointer, symbolTables, localTablePointer, entries, keyBuf, procEntryIndex, paramCount);
    
    outgoingAreaSize := 0;
    outgoing_area(ast, astPointer, symbolTables, tablePointer, entries, keyBuf, outgoingAreaSize);
    STACK_LAYOUT_OUT_AREA_SIZE := outgoingAreaSize;
}

proc var_alloc_rec(
    ref ast: DataArray, 
    ref astPointer: int, 
    ref symbolTables: SymbolTables, 
    tablePointer: int, 
    ref entries: DataArray,
    ref keyBuf: HashMapKeyBuffer
) {
    var nodeType: int;
    var nodeLength: int;
    var t: int;
   
    nodeType := ast[astPointer];
    astPointer := astPointer + 1;

    nodeLength := ast[astPointer];
    astPointer := astPointer + 1;

    if (nodeType = NODE_PROC_DECL) {
        var_alloc_proc_decl(ast, astPointer, symbolTables, tablePointer, entries, keyBuf);
    } else if (nodeType = NODE_STMT_LIST) {
        t := astPointer;
        while (astPointer < t + nodeLength) {
            var_alloc_rec(ast, astPointer, symbolTables, tablePointer, entries, keyBuf);
        }
    } else {
        astPointer := astPointer + nodeLength; // Skip unhandled nodes
    }
}

proc var_alloc(ref ast: DataArray, ref symbolTables: SymbolTables, ref symbolTableEntries: DataArray) {
    var astPointer: int;
    var keyBuf: HashMapKeyBuffer;

    astPointer := 0;

    var_alloc_rec(ast, astPointer, symbolTables, 0, symbolTableEntries, keyBuf);
}

proc main() {
    var input: DataArray;
    var inputLength: int;
    var tokenPointer: int;
    var tokens: DataArray;
    var ast: DataArray;
    var symbolTables: SymbolTables;
    var symbolTableEntries: DataArray;
    var symbolTableEntryPointer: int;

    read_input(input, inputLength);

    lex(tokens, tokenPointer, input, inputLength);

    //lex_print_tokens(tokens, tokenPointer);
    parse(ast, tokens);

    //parse_print_ast(ast);

    init_table_maps(symbolTables);

    symbolTableEntryPointer := 0;
    init_global_table(GLOBAL_TABLE, 0, symbolTableEntries, symbolTableEntryPointer);

    //print_table(GLOBAL_TABLE, symbolTableEntries);

    name_analysis(ast, symbolTables, symbolTableEntries, symbolTableEntryPointer);

    //print_tables(symbolTables, symbolTableEntries, 2);

    semantic_analysis(ast, symbolTables, symbolTableEntries, symbolTableEntryPointer);

    var_alloc(ast, symbolTables, symbolTableEntries);

    printc('s'); printc('u'); printc('c'); printc('c'); printc('e'); printc('s'); printc('s'); printc('\n');
}