#define HASHMAP_SIZE 2048
#define HASHMAP_KEY_SIZE 64
#define MAX_SYMBOL_TABLES 128

#define HASH_KEY_START(h) h[0]
#define HASH_KEY_LEN(h) h[1]
#define HASH_VAL(h) h[2]
#define HASH_USED(h) h[3]
#define HASH_POOL(h) h[4]

type HashMapKeyBuffer = array[HASHMAP_KEY_SIZE] of int;
type HashMapComponent = array[HASHMAP_SIZE] of int;
type HashMap = array[5] of HashMapComponent;

proc hash_map_print_key(ref keyBuf: HashMapKeyBuffer, keyLen: int) {
    var i: int;

    i := 0;
    while (i < keyLen) {
        printc(keyBuf[i]);

        i := i + 1;
    }
}

proc hash_string(ref data: HashMapKeyBuffer, length: int, ref result: int) {
    var h: int;
    var i: int;
    var c: int;

    h := 0;
    i := 0;
    while (i < length) {
        c := data[i];

        h := h * 31 + c;

        while (h >= HASHMAP_SIZE) {
            h := h - HASHMAP_SIZE;
        }

        i := i + 1;
    }

    result := h;
}

proc string_equals_buf_pool(
    ref buf: HashMapKeyBuffer, // external buffer
    len1: int,        // slice in buf (0 - len)
    ref pool: HashMapComponent,
    s2: int, len2: int,        // slice in pool (stored key)
    ref result: int
) {
    var i: int;
    var c1: int;
    var c2: int;

    result := 0;

    if (len1 = len2) {
        i := 0;
        result := 1;
        while (i < len1) {
            c1 := buf[i];
            c2 := pool[s2 + i + 1];   // +1 because pool[0] is the pool pointer
            if (c1 # c2) {
                result := 0;
                i := len1; 
            } else {
                i := i + 1;
            }
        }
    }
}

proc hashmap_cpy_key(ref source: DataArray, ref target: HashMapKeyBuffer, start: int, length: int) {
    var i: int;

    i := 0;
    while (i < length) {
        target[i] := source[start + i];
        i := i + 1;
    }
}

proc hashmap_init(ref map: HashMap) {
    var i: int;

    HASH_POOL(map)[0] := 1;   // first element is "next free" pointer

    i := 0;
    while (i < HASHMAP_SIZE) {
        HASH_USED(map)[i] := 0;
        i := i + 1;
    }
}

proc hashmap_put_str(
    ref map: HashMap,
    ref keyBuf: HashMapKeyBuffer,
    keyLen: int,
    value: int
) {
    var h: int;
    var idx: int;
    var i: int;
    var eq: int;
    var poolPos: int;
    var j: int;

    hash_string(keyBuf, keyLen, h);
    idx := h;

    i := 0;
    while (i < HASHMAP_SIZE) {
        if (HASH_USED(map)[idx] = 0) {
            poolPos := HASH_POOL(map)[0]; 
            j := 0;
            while (j < keyLen) {
                HASH_POOL(map)[poolPos + j] := keyBuf[j];
                j := j + 1;
            }
            HASH_POOL(map)[0] := poolPos + keyLen;

            HASH_USED(map)[idx] := 1;
            HASH_KEY_START(map)[idx] := poolPos - 1;  // minus 1 because pool is offset by 1 in equals
            HASH_KEY_LEN(map)[idx] := keyLen;
            HASH_VAL(map)[idx] := value;

            i := HASHMAP_SIZE;               // break
        } else {
            // check if same key: compare external buf vs stored pool copy
            string_equals_buf_pool(
                keyBuf, keyLen,
                HASH_POOL(map),
                HASH_KEY_START(map)[idx], HASH_KEY_LEN(map)[idx],
                eq
            );
            if (eq # 0) {
                // same key, update value
                HASH_VAL(map)[idx] := value;
                i := HASHMAP_SIZE;           // break
            } else {
                idx := idx + 1;
                if (idx = HASHMAP_SIZE) {
                    idx := 0;
                }
                i := i + 1;
            }
        }
    }

    // TODO: handle full table
}

proc hashmap_get_str(
    ref map: HashMap,
    ref keyBuf: HashMapKeyBuffer,
    keyLen: int,
    ref found: int,
    ref result: int
) {
    var h: int;
    var idx: int;
    var i: int;
    var eq: int;

    // hash from external buffer
    hash_string(keyBuf, keyLen, h);
    idx := h;

    found := 0;
    i := 0;
    while (i < HASHMAP_SIZE) {
        if (HASH_USED(map)[idx] = 0) {
            // empty slot: not present
            i := HASHMAP_SIZE;       // break
        } else {
            string_equals_buf_pool(
                keyBuf, keyLen,
                HASH_POOL(map),
                HASH_KEY_START(map)[idx], HASH_KEY_LEN(map)[idx],
                eq
            );
            if (eq # 0) {
                found := 1;
                result := HASH_VAL(map)[idx];
                i := HASHMAP_SIZE;   // break
            } else {
                idx := idx + 1;
                if (idx = HASHMAP_SIZE) {
                    idx := 0;
                }
                i := i + 1;
            }
        }
    }
}
